{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Framework X documentation \u00b6 This folder contains the source documentation files for Framework X. You can see the website for the user-accessible version. Contribute \u00b6 Found a typo or want to contribute? This folder contains everything you need to help out with the documentation. We use mkdocs-material to render our documentation to a pretty HTML version. If you want to contribute to the documentation, it's easiest to just run this in a Docker container in the project root directory like this: docker compose -f docs/compose.yaml up You can access the documentation via http://localhost:8000 . Props to mkdocs, this uses live reloading, so that every change you do while this Docker container is running should immediately be reflected in your web browser. If you want to generate a static HTML folder for deployment, you can again use a Docker container in the project root directory like this: docker compose -f docs/compose.yaml run -u $( id -u ) build The resulting build/docs/ should then be deployed behind a web server. See also the Framework X website repository for more details about the website itself. If you want to add a new documentation file and/or change the page order, make sure the mkdocs.yml file contains an up-to-date list of all pages. Happy hacking!","title":"Framework X documentation"},{"location":"#framework-x-documentation","text":"This folder contains the source documentation files for Framework X. You can see the website for the user-accessible version.","title":"Framework X documentation"},{"location":"#contribute","text":"Found a typo or want to contribute? This folder contains everything you need to help out with the documentation. We use mkdocs-material to render our documentation to a pretty HTML version. If you want to contribute to the documentation, it's easiest to just run this in a Docker container in the project root directory like this: docker compose -f docs/compose.yaml up You can access the documentation via http://localhost:8000 . Props to mkdocs, this uses live reloading, so that every change you do while this Docker container is running should immediately be reflected in your web browser. If you want to generate a static HTML folder for deployment, you can again use a Docker container in the project root directory like this: docker compose -f docs/compose.yaml run -u $( id -u ) build The resulting build/docs/ should then be deployed behind a web server. See also the Framework X website repository for more details about the website itself. If you want to add a new documentation file and/or change the page order, make sure the mkdocs.yml file contains an up-to-date list of all pages. Happy hacking!","title":"Contribute"},{"location":"api/app/","text":"App \u00b6 The App class is your main entrypoint to any application that builds on top of X. It provides a simple API for routing HTTP requests as commonly used in RESTful applications. public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); // Register routes here, see routing\u2026 $app -> run (); Routing \u00b6 The App class offers a number of API methods that allow you to route incoming HTTP requests to controller functions. In its most simple form, you can add multiple routes using inline closures like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { return React\\Http\\Message\\Response :: plaintext ( \"Hello everybody! \\n \" ); }); $app -> get ( '/user/{id}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $id = $request -> getAttribute ( 'id' ); return React\\Http\\Message\\Response :: plaintext ( \"Hello $id ! \\n \" ); }); For example, an HTTP GET request for /user would call the first controller function. An HTTP GET request for /user/alice would call the second controller function which also highlights how you can use request attributes to access values from URI templates. An HTTP GET request for /foo would automatically reject the HTTP request with a 404 Not Found error response unless this route is registered. Likewise, an HTTP POST request for /user would reject with a 405 Method Not Allowed error response unless a route for this method is also registered. You can route any number of incoming HTTP requests to controller functions by using the matching API methods like this: public/index.php <?php // \u2026 $app -> get ( '/user/{id}' , $controller ); $app -> head ( '/user/{id}' , $controller ); $app -> post ( '/user/{id}' , $controller ); $app -> put ( '/user/{id}' , $controller ); $app -> patch ( '/user/{id}' , $controller ); $app -> delete ( '/user/{id}' , $controller ); $app -> options ( '/user/{id}' , $controller ); If you want to map multiple HTTP request methods to a single controller, you can use this shortcut instead of listing each method explicitly like above: public/index.php <?php // \u2026 $app -> map ([ 'GET' , 'POST' ], '/user/{id}' , $controller ); If you want to map each and every HTTP request method to a single controller, you can use this additional shortcut: public/index.php <?php // \u2026 $app -> any ( '/user/{id}' , $controller ); Any registered GET routes will also match HTTP HEAD requests by default, unless a more explicit HEAD route can also be matched. Responses to HTTP HEAD requests can never have a response body, so X will automatically discard any HTTP response body in this case. Redirects \u00b6 The App also offers a convenient helper method to redirect a matching route to a new URL like this: public/index.php <?php // \u2026 $app -> redirect ( '/promo/reactphp' , 'https://reactphp.org/' ); Browsers and search engine crawlers will automatically follow the redirect with the 302 Found status code by default. You can optionally pass a custom redirect status code in the 3xx range to use. If this is a permanent redirect, you may want to use the 301 Moved Permanently status code to instruct search engine crawlers to update their index like this: public/index.php <?php // \u2026 $app -> redirect ( '/blog.html' , '/blog' , React\\Http\\Message\\Response :: STATUS_MOVED_PERMANENTLY ); See response status codes and HTTP redirects for more details. Controllers \u00b6 The above examples use inline closures as controller functions to make these examples more concise: public/index.php <?php // \u2026 $app -> get ( '/' , function () { return React\\Http\\Message\\Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); }); While easy to get started, it's easy to see how this would become a mess once you keep adding more controllers to a single application. For this reason, we recommend using controller classes for production use-cases like this: Using controller instances Using controller names public/index.php <?php // \u2026 $app -> get ( '/' , new Acme\\Todo\\HelloController ()); public/index.php <?php // \u2026 $app -> get ( '/' , Acme\\Todo\\HelloController :: class ); src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); } } See controller classes for more details. Middleware \u00b6 One of the main features of the App is middleware support. Middleware allows you to extract common functionality such as HTTP login, session handling or logging into reusable components. These middleware components can be added to both individual routes or globally to all registered routes. See middleware documentation for more details. Error handling \u00b6 Each controller function needs to return a response object in order to send an HTTP response message. If the controller function throws an Exception (or Throwable ) or returns any invalid type, the HTTP request will automatically be rejected with a 500 Internal Server Error HTTP error response: <?php // \u2026 $app -> get ( '/user' , function () { throw new BadMethodCallException (); }); You can try out this example by sending an HTTP request like this: $ curl -I http://localhost:8080/user HTTP/1.1 500 Internal Server Error \u2026 Internally, the App will automatically add a default error handler by adding the ErrorHandler to the list of middleware used. You may also explicitly pass an ErrorHandler middleware to the App like this: Using middleware instances Using middleware names public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( new FrameworkX\\ErrorHandler () ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( FrameworkX\\ErrorHandler :: class ); // \u2026 If you do not explicitly pass an ErrorHandler or if you pass another middleware before an ErrorHandler to the App , a default error handler will be added as a first handler automatically. You may use the DI container configuration to configure the default error handler like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ FrameworkX\\ErrorHandler :: class => fn () => new FrameworkX\\ErrorHandler () ]); $app = new FrameworkX\\App ( $container ); // \u2026 By default, this error message contains only few details to the client to avoid leaking too much internal information. If you want to implement custom error handling, you're recommended to either catch any exceptions your own or use a custom middleware handler to catch any exceptions in your application. Access log \u00b6 If you're using X with its built-in web server , it will log all requests and responses to console output ( STDOUT ) by default. $ php public/index.php 2023 -07-21 17 :30:03.617 Listening on http://0.0.0.0:8080 2023 -07-21 17 :30:03.725 127 .0.0.1 \"GET / HTTP/1.1\" 200 13 0 .000 2023 -07-21 17 :30:03.742 127 .0.0.1 \"GET /unknown HTTP/1.1\" 404 956 0 .000 \u2139\ufe0f Framework X runs anywhere This example uses the efficient built-in web server written in pure PHP. We also support running behind traditional web server setups like Apache, nginx, and more. If you're using X behind a traditional web server, X will not write an access log itself, but your web server of choice can be configured to write an access log instead. See production deployment for more details. Internally, the App will automatically add a default access log handler by adding the AccessLogHandler to the list of middleware used. You may also explicitly pass an AccessLogHandler middleware to the App like this: Using middleware instances Using middleware names public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( new FrameworkX\\AccessLogHandler (), new FrameworkX\\ErrorHandler () ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( FrameworkX\\AccessLogHandler :: class , FrameworkX\\ErrorHandler :: class ); // \u2026 \u26a0\ufe0f Feature preview Note that the AccessLogHandler may currently only be passed as a global middleware to the App and may not be used for individual routes. If you pass an AccessLogHandler to the App , it must be followed by an ErrorHandler like in the previous example. See also error handling for more details. If you do not explicitly pass an AccessLogHandler to the App , a default access log handler will be added as a first handler automatically. You may use the DI container configuration to configure the default access log handler like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ FrameworkX\\AccessLogHandler :: class => fn () => new FrameworkX\\AccessLogHandler () ]); $app = new FrameworkX\\App ( $container ); // \u2026 If you do not want to log to the console, you can configure an absolute log file path by passing an argument to the AccessLogHandler like this: Using DI container Using middleware instances public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ 'accesslog' => __DIR__ . '/../logs/access.log' , FrameworkX\\AccessLogHandler :: class => fn ( string $accesslog ) => new FrameworkX\\AccessLogHandler ( $accesslog ) ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( new FrameworkX\\AccessLogHandler ( __DIR__ . '/../logs/access.log' ), new FrameworkX\\ErrorHandler () ); // \u2026 Likewise, you can disable writing an access log by passing an absolute path to /dev/null (Unix) or nul (Windows) like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ 'accesslog' => DIRECTORY_SEPARATOR !== '\\\\' ? '/dev/null' : __DIR__ . '\\\\nul' FrameworkX\\AccessLogHandler :: class => fn ( string $accesslog ) => new FrameworkX\\AccessLogHandler ( $accesslog ), ]); $app = new FrameworkX\\App ( $container ); // \u2026 X supports running behind reverse proxies just fine. However, by default it will see the IP address of the last proxy server as the client IP address (this will often be 127.0.0.1 ). You can get the original client IP address if you configure your proxy server to forward the original client IP address in the X-Forwarded-For (XFF) or Forwarded HTTP request header. If you want to use these trusted headers, you may use a custom middleware to read the IP from this header before passing it to the AccessLogHandler like this: Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\TrustedProxyMiddleware ; require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( new TrustedProxyMiddleware (), new FrameworkX\\AccessLogHandler (), new FrameworkX\\ErrorHandler () ); // \u2026 public/index.php <?php use Acme\\Todo\\TrustedProxyMiddleware ; require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( TrustedProxyMiddleware :: class , FrameworkX\\AccessLogHandler :: class , FrameworkX\\ErrorHandler :: class ); // \u2026 src/TrustedProxyMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; class TrustedProxyMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { // use 127.0.0.1 as trusted proxy to read from X-Forwarded-For (XFF) $remote_addr = $request -> getAttribute ( 'remote_addr' ) ?? $request -> getServerParams ()[ 'REMOTE_ADDR' ] ?? null ; if ( $remote_addr === '127.0.0.1' && $request -> hasHeader ( 'X-Forwarded-For' )) { $remote_addr = preg_replace ( '/,.*/' , '' , $request -> getHeaderLine ( 'X-Forwarded-For' )); $request = $request -> withAttribute ( 'remote_addr' , $remote_addr ); } return $next ( $request ); } } See also middleware handling for more details.","title":"App"},{"location":"api/app/#app","text":"The App class is your main entrypoint to any application that builds on top of X. It provides a simple API for routing HTTP requests as commonly used in RESTful applications. public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); // Register routes here, see routing\u2026 $app -> run ();","title":"App"},{"location":"api/app/#routing","text":"The App class offers a number of API methods that allow you to route incoming HTTP requests to controller functions. In its most simple form, you can add multiple routes using inline closures like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { return React\\Http\\Message\\Response :: plaintext ( \"Hello everybody! \\n \" ); }); $app -> get ( '/user/{id}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $id = $request -> getAttribute ( 'id' ); return React\\Http\\Message\\Response :: plaintext ( \"Hello $id ! \\n \" ); }); For example, an HTTP GET request for /user would call the first controller function. An HTTP GET request for /user/alice would call the second controller function which also highlights how you can use request attributes to access values from URI templates. An HTTP GET request for /foo would automatically reject the HTTP request with a 404 Not Found error response unless this route is registered. Likewise, an HTTP POST request for /user would reject with a 405 Method Not Allowed error response unless a route for this method is also registered. You can route any number of incoming HTTP requests to controller functions by using the matching API methods like this: public/index.php <?php // \u2026 $app -> get ( '/user/{id}' , $controller ); $app -> head ( '/user/{id}' , $controller ); $app -> post ( '/user/{id}' , $controller ); $app -> put ( '/user/{id}' , $controller ); $app -> patch ( '/user/{id}' , $controller ); $app -> delete ( '/user/{id}' , $controller ); $app -> options ( '/user/{id}' , $controller ); If you want to map multiple HTTP request methods to a single controller, you can use this shortcut instead of listing each method explicitly like above: public/index.php <?php // \u2026 $app -> map ([ 'GET' , 'POST' ], '/user/{id}' , $controller ); If you want to map each and every HTTP request method to a single controller, you can use this additional shortcut: public/index.php <?php // \u2026 $app -> any ( '/user/{id}' , $controller ); Any registered GET routes will also match HTTP HEAD requests by default, unless a more explicit HEAD route can also be matched. Responses to HTTP HEAD requests can never have a response body, so X will automatically discard any HTTP response body in this case.","title":"Routing"},{"location":"api/app/#redirects","text":"The App also offers a convenient helper method to redirect a matching route to a new URL like this: public/index.php <?php // \u2026 $app -> redirect ( '/promo/reactphp' , 'https://reactphp.org/' ); Browsers and search engine crawlers will automatically follow the redirect with the 302 Found status code by default. You can optionally pass a custom redirect status code in the 3xx range to use. If this is a permanent redirect, you may want to use the 301 Moved Permanently status code to instruct search engine crawlers to update their index like this: public/index.php <?php // \u2026 $app -> redirect ( '/blog.html' , '/blog' , React\\Http\\Message\\Response :: STATUS_MOVED_PERMANENTLY ); See response status codes and HTTP redirects for more details.","title":"Redirects"},{"location":"api/app/#controllers","text":"The above examples use inline closures as controller functions to make these examples more concise: public/index.php <?php // \u2026 $app -> get ( '/' , function () { return React\\Http\\Message\\Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); }); While easy to get started, it's easy to see how this would become a mess once you keep adding more controllers to a single application. For this reason, we recommend using controller classes for production use-cases like this: Using controller instances Using controller names public/index.php <?php // \u2026 $app -> get ( '/' , new Acme\\Todo\\HelloController ()); public/index.php <?php // \u2026 $app -> get ( '/' , Acme\\Todo\\HelloController :: class ); src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); } } See controller classes for more details.","title":"Controllers"},{"location":"api/app/#middleware","text":"One of the main features of the App is middleware support. Middleware allows you to extract common functionality such as HTTP login, session handling or logging into reusable components. These middleware components can be added to both individual routes or globally to all registered routes. See middleware documentation for more details.","title":"Middleware"},{"location":"api/app/#error-handling","text":"Each controller function needs to return a response object in order to send an HTTP response message. If the controller function throws an Exception (or Throwable ) or returns any invalid type, the HTTP request will automatically be rejected with a 500 Internal Server Error HTTP error response: <?php // \u2026 $app -> get ( '/user' , function () { throw new BadMethodCallException (); }); You can try out this example by sending an HTTP request like this: $ curl -I http://localhost:8080/user HTTP/1.1 500 Internal Server Error \u2026 Internally, the App will automatically add a default error handler by adding the ErrorHandler to the list of middleware used. You may also explicitly pass an ErrorHandler middleware to the App like this: Using middleware instances Using middleware names public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( new FrameworkX\\ErrorHandler () ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( FrameworkX\\ErrorHandler :: class ); // \u2026 If you do not explicitly pass an ErrorHandler or if you pass another middleware before an ErrorHandler to the App , a default error handler will be added as a first handler automatically. You may use the DI container configuration to configure the default error handler like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ FrameworkX\\ErrorHandler :: class => fn () => new FrameworkX\\ErrorHandler () ]); $app = new FrameworkX\\App ( $container ); // \u2026 By default, this error message contains only few details to the client to avoid leaking too much internal information. If you want to implement custom error handling, you're recommended to either catch any exceptions your own or use a custom middleware handler to catch any exceptions in your application.","title":"Error handling"},{"location":"api/app/#access-log","text":"If you're using X with its built-in web server , it will log all requests and responses to console output ( STDOUT ) by default. $ php public/index.php 2023 -07-21 17 :30:03.617 Listening on http://0.0.0.0:8080 2023 -07-21 17 :30:03.725 127 .0.0.1 \"GET / HTTP/1.1\" 200 13 0 .000 2023 -07-21 17 :30:03.742 127 .0.0.1 \"GET /unknown HTTP/1.1\" 404 956 0 .000 \u2139\ufe0f Framework X runs anywhere This example uses the efficient built-in web server written in pure PHP. We also support running behind traditional web server setups like Apache, nginx, and more. If you're using X behind a traditional web server, X will not write an access log itself, but your web server of choice can be configured to write an access log instead. See production deployment for more details. Internally, the App will automatically add a default access log handler by adding the AccessLogHandler to the list of middleware used. You may also explicitly pass an AccessLogHandler middleware to the App like this: Using middleware instances Using middleware names public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( new FrameworkX\\AccessLogHandler (), new FrameworkX\\ErrorHandler () ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( FrameworkX\\AccessLogHandler :: class , FrameworkX\\ErrorHandler :: class ); // \u2026 \u26a0\ufe0f Feature preview Note that the AccessLogHandler may currently only be passed as a global middleware to the App and may not be used for individual routes. If you pass an AccessLogHandler to the App , it must be followed by an ErrorHandler like in the previous example. See also error handling for more details. If you do not explicitly pass an AccessLogHandler to the App , a default access log handler will be added as a first handler automatically. You may use the DI container configuration to configure the default access log handler like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ FrameworkX\\AccessLogHandler :: class => fn () => new FrameworkX\\AccessLogHandler () ]); $app = new FrameworkX\\App ( $container ); // \u2026 If you do not want to log to the console, you can configure an absolute log file path by passing an argument to the AccessLogHandler like this: Using DI container Using middleware instances public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ 'accesslog' => __DIR__ . '/../logs/access.log' , FrameworkX\\AccessLogHandler :: class => fn ( string $accesslog ) => new FrameworkX\\AccessLogHandler ( $accesslog ) ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( new FrameworkX\\AccessLogHandler ( __DIR__ . '/../logs/access.log' ), new FrameworkX\\ErrorHandler () ); // \u2026 Likewise, you can disable writing an access log by passing an absolute path to /dev/null (Unix) or nul (Windows) like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ 'accesslog' => DIRECTORY_SEPARATOR !== '\\\\' ? '/dev/null' : __DIR__ . '\\\\nul' FrameworkX\\AccessLogHandler :: class => fn ( string $accesslog ) => new FrameworkX\\AccessLogHandler ( $accesslog ), ]); $app = new FrameworkX\\App ( $container ); // \u2026 X supports running behind reverse proxies just fine. However, by default it will see the IP address of the last proxy server as the client IP address (this will often be 127.0.0.1 ). You can get the original client IP address if you configure your proxy server to forward the original client IP address in the X-Forwarded-For (XFF) or Forwarded HTTP request header. If you want to use these trusted headers, you may use a custom middleware to read the IP from this header before passing it to the AccessLogHandler like this: Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\TrustedProxyMiddleware ; require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( new TrustedProxyMiddleware (), new FrameworkX\\AccessLogHandler (), new FrameworkX\\ErrorHandler () ); // \u2026 public/index.php <?php use Acme\\Todo\\TrustedProxyMiddleware ; require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App ( TrustedProxyMiddleware :: class , FrameworkX\\AccessLogHandler :: class , FrameworkX\\ErrorHandler :: class ); // \u2026 src/TrustedProxyMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; class TrustedProxyMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { // use 127.0.0.1 as trusted proxy to read from X-Forwarded-For (XFF) $remote_addr = $request -> getAttribute ( 'remote_addr' ) ?? $request -> getServerParams ()[ 'REMOTE_ADDR' ] ?? null ; if ( $remote_addr === '127.0.0.1' && $request -> hasHeader ( 'X-Forwarded-For' )) { $remote_addr = preg_replace ( '/,.*/' , '' , $request -> getHeaderLine ( 'X-Forwarded-For' )); $request = $request -> withAttribute ( 'remote_addr' , $remote_addr ); } return $next ( $request ); } } See also middleware handling for more details.","title":"Access log"},{"location":"api/middleware/","text":"Middleware \u00b6 \u2139\ufe0f New to middleware? Middleware allows modifying the incoming request and outgoing response messages and extracting this logic into reusable components. This is frequently used for common functionality such as HTTP login, session handling, logging, and much more. Inline middleware functions \u00b6 Middleware is any piece of logic that will wrap around your request handler. You can add any number of middleware handlers to each route. To get started, let's take a look at a basic middleware handler by adding an additional callable before the final controller like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request , callable $next ) { // optionally return response without passing to next handler // return React\\Http\\Message\\Response::plaintext(\"Done.\\n\"); // optionally modify request before passing to next handler // $request = $request->withAttribute('admin', false); // call next handler in chain $response = $next ( $request ); assert ( $response instanceof Psr\\Http\\Message\\ResponseInterface ); // optionally modify response before returning to previous handler // $response = $response->withHeader('Content-Type', 'text/plain'); return $response ; }, function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $role = $request -> getAttribute ( 'admin' ) ? 'admin' : 'user' ; return React\\Http\\Message\\Response :: plaintext ( \"Hello $role ! \\n \" ); } ); This example shows how you could build your own middleware that can modifying the incoming request and outgoing response messages alike. Each middleware is responsible for calling the next handler in the chain or directly returning an error response if the request should not be processed. Middleware classes \u00b6 While inline functions are easy to get started, it's easy to see how this would become a mess once you keep adding more controllers to a single application. For this reason, we recommend using middleware classes for production use-cases like this: src/DemoMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; class DemoMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { // optionally return response without passing to next handler // return React\\Http\\Message\\Response::plaintext(\"Done.\\n\"); // optionally modify request before passing to next handler // $request = $request->withAttribute('admin', false); // call next handler in chain $response = $next ( $request ); assert ( $response instanceof ResponseInterface ); // optionally modify response before returning to previous handler // $response = $response->withHeader('Content-Type', 'text/plain'); return $response ; } } Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\DemoMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new DemoMiddleware (), new UserController ()); public/index.php <?php use Acme\\Todo\\DemoMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , DemoMiddleware :: class , UserController :: class ); This highlights how middleware classes provide the exact same functionality as using inline functions, yet provide a cleaner and more reusable structure. Accordingly, all examples below use middleware classes as the recommended style. \u2139\ufe0f New to Composer autoloading? This example uses namespaced classes as the recommended way in the PHP ecosystem. If you're new to setting up your project structure, see also controller classes for more details. Request middleware \u00b6 To get started, we can add an example middleware handler that can modify the incoming request: src/AdminMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; class AdminMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $ip = $request -> getServerParams ()[ 'REMOTE_ADDR' ]; if ( $ip === '127.0.0.1' ) { $request = $request -> withAttribute ( 'admin' , true ); } return $next ( $request ); } } src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { $role = $request -> getAttribute ( 'admin' ) ? 'admin' : 'user' ; return Response :: plaintext ( \"Hello $role ! \\n \" ); } } Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\AdminMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new AdminMiddleware (), new UserController ()); public/index.php <?php use Acme\\Todo\\AdminMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , AdminMiddleware :: class , UserController :: class ); For example, an HTTP GET request for /user would first call the middleware handler which then modifies this request and passes the modified request to the next controller function. This is commonly used for HTTP authentication, login handling and session handling. Note that this example only modifies the incoming request object and simply returns whatever the next request handler returns without modifying the outgoing response. This means this works both when the next request handler returns a response object synchronously or if you're using an async request handler that may return a promise or coroutine . If you want to modify the outgoing response object, see also the next chapter. Response middleware \u00b6 Likewise, we can add an example middleware handler that can modify the outgoing response: src/ContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; class ContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); assert ( $response instanceof ResponseInterface ); return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { $name = 'Alice' ; return Response :: plaintext ( \"Hello $name ! \\n \" ); } } Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\ContentTypeMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new ContentTypeMiddleware (), new UserController ()); public/index.php <?php use Acme\\Todo\\ContentTypeMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , ContentTypeMiddleware :: class , UserController :: class ); For example, an HTTP GET request for /user would first call the middleware handler which passes on the request to the controller function and then modifies the response that is returned by the controller function. This is commonly used for cache handling and response body transformations (compression etc.). Note that this example assumes the next request handler returns a response object synchronously. If you're writing a middleware that also needs to support async request handlers that may return a promise or coroutine , see also the next chapter. Async middleware \u00b6 One of the core features of X is its async support. As a consequence, each middleware handler can also return promises or coroutines . While request middleware doesn't usually have to care about async responses, this particularly affects response middleware that wants to change the outgoing response. Here's an example middleware handler that can modify the outgoing response no matter whether the next request handler returns a promise , a coroutine or a response object synchronously: Arrow functions (PHP 7.4+) Match syntax (PHP 8.0+) Closures src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); if ( $response instanceof PromiseInterface ) { return $response -> then ( fn ( ResponseInterface $response ) => $this -> handle ( $response )); } elseif ( $response instanceof \\Generator ) { return ( fn () => $this -> handle ( yield from $response ))(); } else { return $this -> handle ( $response ); } } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); return match ( true ) { $response instanceof PromiseInterface => $response -> then ( fn ( ResponseInterface $response ) => $this -> handle ( $response )), $response instanceof \\Generator => ( fn () => $this -> handle ( yield from $response ))(), default => $this -> handle ( $response ), }; } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); if ( $response instanceof PromiseInterface ) { return $response -> then ( function ( ResponseInterface $response ) { return $this -> handle ( $response ); }); } elseif ( $response instanceof \\Generator ) { return ( function () use ( $response ) { return $this -> handle ( yield from $response ); })(); } else { return $this -> handle ( $response ); } } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } Coroutines Promises src/AsyncUserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\EventLoop\\Loop ; use React\\Http\\Message\\Response ; use React\\Promise\\Promise ; use React\\Promise\\PromiseInterface ; class AsyncUserController { public function __invoke ( ServerRequestInterface $request ) : \\Generator { // async pseudo code to load some data from an external source $promise = $this -> fetchRandomUserName (); $name = yield $promise ; assert ( is_string ( $name )); return Response :: plaintext ( \"Hello $name ! \\n \" ); } /** * @return PromiseInterface<string> */ private function fetchRandomUserName () : PromiseInterface { return new Promise ( function ( $resolve ) { Loop :: addTimer ( 0.01 , function () use ( $resolve ) { $resolve ( 'Alice' ); }); }); } } src/AsyncUserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\EventLoop\\Loop ; use React\\Http\\Message\\Response ; use React\\Promise\\Promise ; use React\\Promise\\PromiseInterface ; class AsyncUserController { /** * @return PromiseInterface<Response> */ public function __invoke ( ServerRequestInterface $request ) : PromiseInterface { // async pseudo code to load some data from an external source return $this -> fetchRandomUserName () -> then ( function ( string $name ) { return Response :: plaintext ( \"Hello $name ! \\n \" ); }); } /** * @return PromiseInterface<string> */ private function fetchRandomUserName () : PromiseInterface { return new Promise ( function ( $resolve ) { Loop :: addTimer ( 0.01 , function () use ( $resolve ) { $resolve ( 'Alice' ); }); }); } } Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\AsyncContentTypeMiddleware ; use Acme\\Todo\\AsyncUserController ; // \u2026 $app -> get ( '/user' , new AsyncContentTypeMiddleware (), new AsyncUserController ()); public/index.php <?php use Acme\\Todo\\AsyncContentTypeMiddleware ; use Acme\\Todo\\AsyncUserController ; // \u2026 $app -> get ( '/user' , AsyncContentTypeMiddleware :: class , AsyncUserController :: class ); For example, an HTTP GET request for /user would first call the middleware handler which passes on the request to the controller function and then modifies the response that is returned by the controller function. This is commonly used for cache handling and response body transformations (compression etc.). \ud83d\udd2e Future fiber support in PHP 8.1 In the future, PHP 8.1 will provide native support for fibers . Once fibers become mainstream, we can simplify this example significantly because we wouldn't have to use promises or Generator-based coroutines anymore. See fibers for more details. Global middleware \u00b6 Additionally, you can also add middleware to the App object itself to register a global middleware handler: Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\AsyncContentTypeMiddleware ; use Acme\\Todo\\AsyncUserController ; $app = new FrameworkX\\App ( new AdminMiddleware ()); $app -> get ( '/user' , new UserController ()); $app -> run (); public/index.php <?php use Acme\\Todo\\AsyncContentTypeMiddleware ; use Acme\\Todo\\AsyncUserController ; $app = new FrameworkX\\App ( AdminMiddleware :: class ); $app -> get ( '/user' , UserController :: class ); $app -> run (); Any global middleware handler will always be called for all registered routes and also any requests that can not be routed. You can also combine global middleware handlers (think logging) with additional middleware handlers for individual routes (think authentication). Global middleware handlers will always be called before route middleware handlers. Built-in middleware \u00b6 AccessLogHandler \u00b6 \u26a0\ufe0f Feature preview This is a feature preview, i.e. it might not have made it into the current beta. Give feedback to help us prioritize. We also welcome contributors to help out! X ships with a built-in AccessLogHandler middleware that is responsible for logging any requests and responses from following middleware and controllers. This default access log handling can be configured through the App . See access logging for more details. ErrorHandler \u00b6 \u26a0\ufe0f Feature preview This is a feature preview, i.e. it might not have made it into the current beta. Give feedback to help us prioritize. We also welcome contributors to help out! X ships with a built-in ErrorHandler middleware that is responsible for handling errors and exceptions returned from following middleware and controllers. This default error handling can be configured through the App . See error handling for more details.","title":"Middleware"},{"location":"api/middleware/#middleware","text":"\u2139\ufe0f New to middleware? Middleware allows modifying the incoming request and outgoing response messages and extracting this logic into reusable components. This is frequently used for common functionality such as HTTP login, session handling, logging, and much more.","title":"Middleware"},{"location":"api/middleware/#inline-middleware-functions","text":"Middleware is any piece of logic that will wrap around your request handler. You can add any number of middleware handlers to each route. To get started, let's take a look at a basic middleware handler by adding an additional callable before the final controller like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request , callable $next ) { // optionally return response without passing to next handler // return React\\Http\\Message\\Response::plaintext(\"Done.\\n\"); // optionally modify request before passing to next handler // $request = $request->withAttribute('admin', false); // call next handler in chain $response = $next ( $request ); assert ( $response instanceof Psr\\Http\\Message\\ResponseInterface ); // optionally modify response before returning to previous handler // $response = $response->withHeader('Content-Type', 'text/plain'); return $response ; }, function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $role = $request -> getAttribute ( 'admin' ) ? 'admin' : 'user' ; return React\\Http\\Message\\Response :: plaintext ( \"Hello $role ! \\n \" ); } ); This example shows how you could build your own middleware that can modifying the incoming request and outgoing response messages alike. Each middleware is responsible for calling the next handler in the chain or directly returning an error response if the request should not be processed.","title":"Inline middleware functions"},{"location":"api/middleware/#middleware-classes","text":"While inline functions are easy to get started, it's easy to see how this would become a mess once you keep adding more controllers to a single application. For this reason, we recommend using middleware classes for production use-cases like this: src/DemoMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; class DemoMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { // optionally return response without passing to next handler // return React\\Http\\Message\\Response::plaintext(\"Done.\\n\"); // optionally modify request before passing to next handler // $request = $request->withAttribute('admin', false); // call next handler in chain $response = $next ( $request ); assert ( $response instanceof ResponseInterface ); // optionally modify response before returning to previous handler // $response = $response->withHeader('Content-Type', 'text/plain'); return $response ; } } Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\DemoMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new DemoMiddleware (), new UserController ()); public/index.php <?php use Acme\\Todo\\DemoMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , DemoMiddleware :: class , UserController :: class ); This highlights how middleware classes provide the exact same functionality as using inline functions, yet provide a cleaner and more reusable structure. Accordingly, all examples below use middleware classes as the recommended style. \u2139\ufe0f New to Composer autoloading? This example uses namespaced classes as the recommended way in the PHP ecosystem. If you're new to setting up your project structure, see also controller classes for more details.","title":"Middleware classes"},{"location":"api/middleware/#request-middleware","text":"To get started, we can add an example middleware handler that can modify the incoming request: src/AdminMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; class AdminMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $ip = $request -> getServerParams ()[ 'REMOTE_ADDR' ]; if ( $ip === '127.0.0.1' ) { $request = $request -> withAttribute ( 'admin' , true ); } return $next ( $request ); } } src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { $role = $request -> getAttribute ( 'admin' ) ? 'admin' : 'user' ; return Response :: plaintext ( \"Hello $role ! \\n \" ); } } Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\AdminMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new AdminMiddleware (), new UserController ()); public/index.php <?php use Acme\\Todo\\AdminMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , AdminMiddleware :: class , UserController :: class ); For example, an HTTP GET request for /user would first call the middleware handler which then modifies this request and passes the modified request to the next controller function. This is commonly used for HTTP authentication, login handling and session handling. Note that this example only modifies the incoming request object and simply returns whatever the next request handler returns without modifying the outgoing response. This means this works both when the next request handler returns a response object synchronously or if you're using an async request handler that may return a promise or coroutine . If you want to modify the outgoing response object, see also the next chapter.","title":"Request middleware"},{"location":"api/middleware/#response-middleware","text":"Likewise, we can add an example middleware handler that can modify the outgoing response: src/ContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; class ContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); assert ( $response instanceof ResponseInterface ); return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { $name = 'Alice' ; return Response :: plaintext ( \"Hello $name ! \\n \" ); } } Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\ContentTypeMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new ContentTypeMiddleware (), new UserController ()); public/index.php <?php use Acme\\Todo\\ContentTypeMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , ContentTypeMiddleware :: class , UserController :: class ); For example, an HTTP GET request for /user would first call the middleware handler which passes on the request to the controller function and then modifies the response that is returned by the controller function. This is commonly used for cache handling and response body transformations (compression etc.). Note that this example assumes the next request handler returns a response object synchronously. If you're writing a middleware that also needs to support async request handlers that may return a promise or coroutine , see also the next chapter.","title":"Response middleware"},{"location":"api/middleware/#async-middleware","text":"One of the core features of X is its async support. As a consequence, each middleware handler can also return promises or coroutines . While request middleware doesn't usually have to care about async responses, this particularly affects response middleware that wants to change the outgoing response. Here's an example middleware handler that can modify the outgoing response no matter whether the next request handler returns a promise , a coroutine or a response object synchronously: Arrow functions (PHP 7.4+) Match syntax (PHP 8.0+) Closures src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); if ( $response instanceof PromiseInterface ) { return $response -> then ( fn ( ResponseInterface $response ) => $this -> handle ( $response )); } elseif ( $response instanceof \\Generator ) { return ( fn () => $this -> handle ( yield from $response ))(); } else { return $this -> handle ( $response ); } } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); return match ( true ) { $response instanceof PromiseInterface => $response -> then ( fn ( ResponseInterface $response ) => $this -> handle ( $response )), $response instanceof \\Generator => ( fn () => $this -> handle ( yield from $response ))(), default => $this -> handle ( $response ), }; } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); if ( $response instanceof PromiseInterface ) { return $response -> then ( function ( ResponseInterface $response ) { return $this -> handle ( $response ); }); } elseif ( $response instanceof \\Generator ) { return ( function () use ( $response ) { return $this -> handle ( yield from $response ); })(); } else { return $this -> handle ( $response ); } } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } Coroutines Promises src/AsyncUserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\EventLoop\\Loop ; use React\\Http\\Message\\Response ; use React\\Promise\\Promise ; use React\\Promise\\PromiseInterface ; class AsyncUserController { public function __invoke ( ServerRequestInterface $request ) : \\Generator { // async pseudo code to load some data from an external source $promise = $this -> fetchRandomUserName (); $name = yield $promise ; assert ( is_string ( $name )); return Response :: plaintext ( \"Hello $name ! \\n \" ); } /** * @return PromiseInterface<string> */ private function fetchRandomUserName () : PromiseInterface { return new Promise ( function ( $resolve ) { Loop :: addTimer ( 0.01 , function () use ( $resolve ) { $resolve ( 'Alice' ); }); }); } } src/AsyncUserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\EventLoop\\Loop ; use React\\Http\\Message\\Response ; use React\\Promise\\Promise ; use React\\Promise\\PromiseInterface ; class AsyncUserController { /** * @return PromiseInterface<Response> */ public function __invoke ( ServerRequestInterface $request ) : PromiseInterface { // async pseudo code to load some data from an external source return $this -> fetchRandomUserName () -> then ( function ( string $name ) { return Response :: plaintext ( \"Hello $name ! \\n \" ); }); } /** * @return PromiseInterface<string> */ private function fetchRandomUserName () : PromiseInterface { return new Promise ( function ( $resolve ) { Loop :: addTimer ( 0.01 , function () use ( $resolve ) { $resolve ( 'Alice' ); }); }); } } Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\AsyncContentTypeMiddleware ; use Acme\\Todo\\AsyncUserController ; // \u2026 $app -> get ( '/user' , new AsyncContentTypeMiddleware (), new AsyncUserController ()); public/index.php <?php use Acme\\Todo\\AsyncContentTypeMiddleware ; use Acme\\Todo\\AsyncUserController ; // \u2026 $app -> get ( '/user' , AsyncContentTypeMiddleware :: class , AsyncUserController :: class ); For example, an HTTP GET request for /user would first call the middleware handler which passes on the request to the controller function and then modifies the response that is returned by the controller function. This is commonly used for cache handling and response body transformations (compression etc.). \ud83d\udd2e Future fiber support in PHP 8.1 In the future, PHP 8.1 will provide native support for fibers . Once fibers become mainstream, we can simplify this example significantly because we wouldn't have to use promises or Generator-based coroutines anymore. See fibers for more details.","title":"Async middleware"},{"location":"api/middleware/#global-middleware","text":"Additionally, you can also add middleware to the App object itself to register a global middleware handler: Using middleware instances Using middleware names public/index.php <?php use Acme\\Todo\\AsyncContentTypeMiddleware ; use Acme\\Todo\\AsyncUserController ; $app = new FrameworkX\\App ( new AdminMiddleware ()); $app -> get ( '/user' , new UserController ()); $app -> run (); public/index.php <?php use Acme\\Todo\\AsyncContentTypeMiddleware ; use Acme\\Todo\\AsyncUserController ; $app = new FrameworkX\\App ( AdminMiddleware :: class ); $app -> get ( '/user' , UserController :: class ); $app -> run (); Any global middleware handler will always be called for all registered routes and also any requests that can not be routed. You can also combine global middleware handlers (think logging) with additional middleware handlers for individual routes (think authentication). Global middleware handlers will always be called before route middleware handlers.","title":"Global middleware"},{"location":"api/middleware/#built-in-middleware","text":"","title":"Built-in middleware"},{"location":"api/middleware/#accessloghandler","text":"\u26a0\ufe0f Feature preview This is a feature preview, i.e. it might not have made it into the current beta. Give feedback to help us prioritize. We also welcome contributors to help out! X ships with a built-in AccessLogHandler middleware that is responsible for logging any requests and responses from following middleware and controllers. This default access log handling can be configured through the App . See access logging for more details.","title":"AccessLogHandler"},{"location":"api/middleware/#errorhandler","text":"\u26a0\ufe0f Feature preview This is a feature preview, i.e. it might not have made it into the current beta. Give feedback to help us prioritize. We also welcome contributors to help out! X ships with a built-in ErrorHandler middleware that is responsible for handling errors and exceptions returned from following middleware and controllers. This default error handling can be configured through the App . See error handling for more details.","title":"ErrorHandler"},{"location":"api/request/","text":"Request \u00b6 Whenever the client sends an HTTP request to our application, we receive it as a request object and need to react to it. We love standards and want to make using X as simple as possible. That's why we build on top of the established PSR-7 standard (HTTP message interfaces). This standard defines common interfaces for HTTP request and response objects. If you've ever used PSR-7 before, you should immediately feel at home when using X. If you're new to PSR-7, don't worry. Here's everything you need to know to get started. \u2139\ufe0f A note about other PSR-7 implementations This documentation uses the Psr\\Http\\Message\\ServerRequestInterface for all examples. The actual class implementing this interface is an implementation detail that should not be relied upon. If you need to construct your own instance, we recommend using the React\\Http\\Message\\ServerRequest class because this comes bundled as part of our dependencies, but you may use any other implementation as long as it implements the same interface. Attributes \u00b6 You can access request attributes like this: public/index.php <?php // \u2026 $app -> get ( '/user/{id}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $id = $request -> getAttribute ( 'id' ); return React\\Http\\Message\\Response :: plaintext ( \"Hello $id ! \\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user/Alice Hello Alice! These custom attributes are most commonly used when using URI placeholders from routing . Each placeholder will automatically be assigned to a matching request attribute. See also routing for more details. Additionally, these custom attributes can also be useful when passing additional information from a middleware handler to other handlers further down the chain (think authentication information). See also middleware for more details. JSON \u00b6 You can access JSON data from the HTTP request body like this: public/index.php <?php // \u2026 $app -> post ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $data = json_decode (( string ) $request -> getBody ()); $name = $data -> name ?? 'anonymous' ; return React\\Http\\Message\\Response :: plaintext ( \"Hello $name ! \\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user --data '{\"name\":\"Alice\"}' Hello Alice! Additionally, you may want to validate the Content-Type: application/json request header to be sure the client intended to send a JSON request body. This example returns a simple text response, you may also want to return a JSON response for common API usage. Form data \u00b6 You can access HTML form data from the HTTP request body like this: public/index.php <?php // \u2026 $app -> post ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $data = $request -> getParsedBody (); $name = $data [ 'name' ] ?? 'Anonymous' ; return React\\Http\\Message\\Response :: plaintext ( \"Hello $name ! \\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -d name = Alice Hello Alice! This method returns a possibly nested array of form fields, very similar to PHP's $_POST superglobal. Uploads \u00b6 You can access any file uploads from HTML forms like this: public/index.php <?php // \u2026 $app -> post ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $files = $request -> getUploadedFiles (); $name = isset ( $files [ 'image' ]) ? $files [ 'image' ] -> getClientFilename () : 'x' ; return React\\Http\\Message\\Response :: plaintext ( \"Uploaded $name\\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -F image = @~/Downloads/image.jpg Uploaded image.jpg This method returns a possibly nested array of files uploaded, very similar to PHP's $_FILES superglobal. Each file in this array implements the Psr\\Http\\Message\\UploadedFileInterface : <?php // \u2026 $files = $request -> getUploadedFiles (); $image = $files [ 'image' ]; assert ( $image instanceof Psr\\Http\\Message\\UploadedFileInterface ); $stream = $image -> getStream (); assert ( $stream instanceof Psr\\Http\\Message\\StreamInterface ); $contents = ( string ) $stream ; $size = $image -> getSize (); assert ( is_int ( $size )); $name = $image -> getClientFilename (); assert ( is_string ( $name ) || $name === null ); $type = $image -> getClientMediaType (); assert ( is_string ( $type ) || $name === null ); \u2139\ufe0f Info Note that HTTP requests are currently limited to 64 KiB. Any uploads above this size will currently show up as an empty request body with no file uploads whatsoever. Headers \u00b6 You can access all HTTP request headers like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $agent = $request -> getHeaderLine ( 'User-Agent' ); return React\\Http\\Message\\Response :: plaintext ( \"Hello $agent\\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -H 'User-Agent: FrameworkX/0' Hello FrameworkX/0 This example returns a simple text response with no additional response headers, you may also want to return response headers for common API usage. Parameters \u00b6 You can access server-side parameters like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $params = $request -> getServerParams (); $ip = $params [ 'REMOTE_ADDR' ] ?? 'unknown' ; return React\\Http\\Message\\Response :: plaintext ( \"Hello $ip\\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user Hello 127 .0.0.1 This method returns an array of server-side parameters, very similar to PHP's $_SERVER superglobal. Note that available server parameters depend on the server software and version in use.","title":"Request"},{"location":"api/request/#request","text":"Whenever the client sends an HTTP request to our application, we receive it as a request object and need to react to it. We love standards and want to make using X as simple as possible. That's why we build on top of the established PSR-7 standard (HTTP message interfaces). This standard defines common interfaces for HTTP request and response objects. If you've ever used PSR-7 before, you should immediately feel at home when using X. If you're new to PSR-7, don't worry. Here's everything you need to know to get started. \u2139\ufe0f A note about other PSR-7 implementations This documentation uses the Psr\\Http\\Message\\ServerRequestInterface for all examples. The actual class implementing this interface is an implementation detail that should not be relied upon. If you need to construct your own instance, we recommend using the React\\Http\\Message\\ServerRequest class because this comes bundled as part of our dependencies, but you may use any other implementation as long as it implements the same interface.","title":"Request"},{"location":"api/request/#attributes","text":"You can access request attributes like this: public/index.php <?php // \u2026 $app -> get ( '/user/{id}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $id = $request -> getAttribute ( 'id' ); return React\\Http\\Message\\Response :: plaintext ( \"Hello $id ! \\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user/Alice Hello Alice! These custom attributes are most commonly used when using URI placeholders from routing . Each placeholder will automatically be assigned to a matching request attribute. See also routing for more details. Additionally, these custom attributes can also be useful when passing additional information from a middleware handler to other handlers further down the chain (think authentication information). See also middleware for more details.","title":"Attributes"},{"location":"api/request/#json","text":"You can access JSON data from the HTTP request body like this: public/index.php <?php // \u2026 $app -> post ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $data = json_decode (( string ) $request -> getBody ()); $name = $data -> name ?? 'anonymous' ; return React\\Http\\Message\\Response :: plaintext ( \"Hello $name ! \\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user --data '{\"name\":\"Alice\"}' Hello Alice! Additionally, you may want to validate the Content-Type: application/json request header to be sure the client intended to send a JSON request body. This example returns a simple text response, you may also want to return a JSON response for common API usage.","title":"JSON"},{"location":"api/request/#form-data","text":"You can access HTML form data from the HTTP request body like this: public/index.php <?php // \u2026 $app -> post ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $data = $request -> getParsedBody (); $name = $data [ 'name' ] ?? 'Anonymous' ; return React\\Http\\Message\\Response :: plaintext ( \"Hello $name ! \\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -d name = Alice Hello Alice! This method returns a possibly nested array of form fields, very similar to PHP's $_POST superglobal.","title":"Form data"},{"location":"api/request/#uploads","text":"You can access any file uploads from HTML forms like this: public/index.php <?php // \u2026 $app -> post ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $files = $request -> getUploadedFiles (); $name = isset ( $files [ 'image' ]) ? $files [ 'image' ] -> getClientFilename () : 'x' ; return React\\Http\\Message\\Response :: plaintext ( \"Uploaded $name\\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -F image = @~/Downloads/image.jpg Uploaded image.jpg This method returns a possibly nested array of files uploaded, very similar to PHP's $_FILES superglobal. Each file in this array implements the Psr\\Http\\Message\\UploadedFileInterface : <?php // \u2026 $files = $request -> getUploadedFiles (); $image = $files [ 'image' ]; assert ( $image instanceof Psr\\Http\\Message\\UploadedFileInterface ); $stream = $image -> getStream (); assert ( $stream instanceof Psr\\Http\\Message\\StreamInterface ); $contents = ( string ) $stream ; $size = $image -> getSize (); assert ( is_int ( $size )); $name = $image -> getClientFilename (); assert ( is_string ( $name ) || $name === null ); $type = $image -> getClientMediaType (); assert ( is_string ( $type ) || $name === null ); \u2139\ufe0f Info Note that HTTP requests are currently limited to 64 KiB. Any uploads above this size will currently show up as an empty request body with no file uploads whatsoever.","title":"Uploads"},{"location":"api/request/#headers","text":"You can access all HTTP request headers like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $agent = $request -> getHeaderLine ( 'User-Agent' ); return React\\Http\\Message\\Response :: plaintext ( \"Hello $agent\\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -H 'User-Agent: FrameworkX/0' Hello FrameworkX/0 This example returns a simple text response with no additional response headers, you may also want to return response headers for common API usage.","title":"Headers"},{"location":"api/request/#parameters","text":"You can access server-side parameters like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $params = $request -> getServerParams (); $ip = $params [ 'REMOTE_ADDR' ] ?? 'unknown' ; return React\\Http\\Message\\Response :: plaintext ( \"Hello $ip\\n \" ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user Hello 127 .0.0.1 This method returns an array of server-side parameters, very similar to PHP's $_SERVER superglobal. Note that available server parameters depend on the server software and version in use.","title":"Parameters"},{"location":"api/response/","text":"Response \u00b6 Whenever the client sends an HTTP request to our application, we need to send back an HTTP response message. We love standards and want to make using X as simple as possible. That's why we build on top of the established PSR-7 standard (HTTP message interfaces). This standard defines common interfaces for HTTP request and response objects. If you've ever used PSR-7 before, you should immediately feel at home when using X. If you're new to PSR-7, don't worry. Here's everything you need to know to get started. \u2139\ufe0f A note about other PSR-7 implementations All of the examples in this documentation use the React\\Http\\Message\\Response class because this comes bundled as part of our dependencies. If you have more specific requirements or want to integrate this with an existing piece of code, you can use any response implementation as long as it implements the Psr\\Http\\Message\\ResponseInterface . JSON \u00b6 You can send JSON data as an HTTP response body like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { $data = [ [ 'name' => 'Alice' ], [ 'name' => 'Bob' ] ]; return React\\Http\\Message\\Response :: json ( $data ); }); This example returns a simple JSON response from some static data. In real-world applications, you may want to load this from a database . For common API usage, you may also want to receive a JSON request . You can try out this example by sending an HTTP request like this: $ curl http://localhost:8080/user [ { \"name\" : \"Alice\" } , { \"name\" : \"Bob\" } ] By default, the response will use the 200 OK status code and will automatically include an appropriate Content-Type: application/json response header, see also status codes and response headers below for more details. If you want more control over the response such as using custom JSON flags, you can also manually create a React\\Http\\Message\\Response object like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { $data = []; return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_OK , [ 'Content-Type' => 'application/json' ], json_encode ( $data , JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ) . \" \\n \" ); }); HTML \u00b6 You can send HTML data as an HTTP response body like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { $html = <<< HTML <h1>Hello Alice</h1> HTML ; return React\\Http\\Message\\Response :: html ( $html ); }); This example returns a simple HTML response from some static data. In real-world applications, you may want to load this from a database and perhaps use templates to render your HTML. You can try out this example by sending an HTTP request like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> By default, the response will use the 200 OK status code and will automatically include an appropriate Content-Type: text/html; charset=utf-8 response header, see also status codes and response headers below for more details. If you want more control over this behavior, you can also manually create a React\\Http\\Message\\Response object like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { $html = \"Hello W\u00f6rld! \\n \" ; return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_OK , [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); Status Codes \u00b6 The json() and html() methods used above automatically use a 200 OK status code by default. You can assign status codes like this: public/index.php <?php // \u2026 $app -> get ( '/user/{id}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $id = $request -> getAttribute ( 'id' ); if ( $id === 'admin' ) { return React\\Http\\Message\\Response :: html ( \"Forbidden \\n \" ) -> withStatus ( React\\Http\\Message\\Response :: STATUS_FORBIDDEN ); } return React\\Http\\Message\\Response :: html ( \"Hello $id\\n \" ); }); You can try out this example by sending an HTTP request like this: $ curl -I http://localhost:8080/user/Alice HTTP/1.1 200 OK \u2026 $ curl -I http://localhost:8080/user/admin HTTP/1.1 403 Forbidden \u2026 Each HTTP response message contains a status code that describes whether the HTTP request has been successfully completed. Here's a list with some of the most common HTTP status codes: 200 OK 301 Moved Permanently 302 Found (previously 302 Temporary Redirect ) 304 Not Modified (see HTTP caching below) 403 Forbidden 404 Not Found 500 Internal Server Error \u2026 See list of HTTP status codes for more details. Each status code can be referenced by its matching status code constant name such as React\\Http\\Message\\Response::STATUS_OK or React\\Http\\Message\\Response::STATUS_NOT_FOUND or by its status code number. Headers \u00b6 The json() and html() methods used above automatically use an appropriate Content-Type response header by default. You can assign HTTP response headers like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { return React\\Http\\Message\\Response :: html ( \"Hello w\u00f6rld! \\n \" ) -> withHeader ( 'Cache-Control' , 'public' ); }); You can try out this example by sending an HTTP request like this: $ curl -I http://localhost:8080/user HTTP/1.1 200 OK Content-Type: text/html ; charset = utf-8 Cache-Control: public Hello w\u00f6rld! Each HTTP response message can contain an arbitrary number of response headers. Additionally, the application will automatically include default headers required by the HTTP protocol. It's not recommended to mess with these default headers unless you're sure you know what you're doing. If you want more control over this behavior, you can also manually create a React\\Http\\Message\\Response object like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_OK , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'public' ], \"Hello w\u00f6rld! \\n \" ); }); HTTP Redirects \u00b6 To redirect incoming HTTP requests to a new location you can define your HTTP response like this: public/index.php <?php // \u2026 $app -> get ( '/blog.html' , function () { return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_FOUND , [ 'Location' => '/blog' ] ); }); Redirect responses have a status code in the 3xx range. Here's a list with some of the most common HTTP redirect status codes: 301 Moved Permanently 302 Found (previously 302 Temporary Redirect ) 303 See Other 307 Temporary Redirect 308 Permanent Redirect Each status code can be referenced by its matching status code constant name such as React\\Http\\Message\\Response::STATUS_MOVED_PERMANENTLY or React\\Http\\Message\\Response::STATUS_FOUND or by its status code number. The Location response header holds the URL to redirect to. When a Browser or a search engine crawler receives a redirect, they will automatically follow the new URL provided in the Location header. You can also use the redirect helper method for simpler use cases: public/index.php <?php // \u2026 $app -> redirect ( '/promo/reactphp' , 'https://reactphp.org/' ); HTTP caching \u00b6 HTTP caching can be used to significantly improve the performance of web applications by reusing previously fetched resources. HTTP caching is a whole topic on its own, so this section only aims to give a basic overview of how you can leverage HTTP caches with X. For a more in-depth overview, we highly recommend MDN . HTTP supports caching for certain requests by default. In any but the most basic use cases, it's often a good idea to explicitly specify HTTP caching headers as part of the HTTP response to have more control over the freshness lifetime and revalidation behavior. Cache-Control \u00b6 The Cache-Control response header can be used to control caching of responses by browsers and shared caches such as proxies and CDNs. In its most basic form, you can use this response header to control the lifetime of a cached response like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { $html = <<< HTML <h1>Hello Alice</h1> HTML ; return new React\\Http\\Message\\Response :: html ( $html ) -> withHeader ( 'Cache-Control' , 'max-age=3600' ); }); You can try out this example by sending an HTTP request like this: $ curl -I http://localhost:8080/user HTTP/1.1 200 OK Cache-Control: max-age = 3600 \u2026 ETag \u00b6 The ETag response header can be used for conditional requests. This ensures the response body only needs to be transferred when it actually changes. For instance, you can build a hash (or some other arbitrary identifier) for your contents and check if it matches the incoming If-None-Match request header for subsequent requests. If both values match, you can send a 304 Not Modified response and omit the response body like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { // example body, would usually come from some kind of database $html = <<< HTML <h1>Hello Alice</h1> HTML ; $etag = '\"' . sha1 ( $html ) . '\"' ; if ( $request -> getHeaderLine ( 'If-None-Match' ) === $etag ) { return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_NOT_MODIFIED , [ 'Cache-Control' => 'max-age=0, must-revalidate' , 'ETag' => $etag ] ); } return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_OK , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'max-age=0, must-revalidate' , 'ETag' => $etag ], $html ); }); You can try out this example by sending an HTTP request like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> $ curl -I http://localhost:8080/user -H 'If-None-Match: \"87637b595ed5b32934c011dc6b33afb43f598865\"' HTTP/1.1 304 Not Modified Cache-Control: max-age = 0 , must-revalidate ETag: \"87637b595ed5b32934c011dc6b33afb43f598865\" \u2026 Last-Modified \u00b6 The Last-Modified response header can be used to signal when a response was last modified. Among others, this can be used to ensure the response body only needs to be transferred when it changes. For instance, you can store a timestamp or datetime for your contents and check if it matches the incoming If-Modified-Since request header for subsequent requests. If both values match, you can send a 304 Not Modified response and omit the response body like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { // example date and body, would usually come from some kind of database $date = new DateTimeImmutable ( '2021-11-06 13:31:04' , new DateTimeZone ( 'Europe/Berlin' ) ); $html = <<< HTML <h1>Hello Alice</h1> HTML ; $modified = gmdate ( 'D, d M Y H:i:s T' , $date -> getTimestamp ()); if ( $request -> getHeaderLine ( 'If-Modified-Since' ) === $modified ) { return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_NOT_MODIFIED , [ 'Cache-Control' => 'max-age=0, must-revalidate' , 'Last-Modified' => $modified ] ); } return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_OK , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'max-age=0, must-revalidate' , 'Last-Modified' => $modified ], $html ); }); You can try out this example by sending an HTTP request like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> $ curl -I http://localhost:8080/user -H 'If-Modified-Since: Sat, 06 Nov 2021 12:31:04 GMT' HTTP/1.1 304 Not Modified Cache-Control: max-age = 0 , must-revalidate Last-Modified: Sat, 06 Nov 2021 12 :31:04 GMT \u2026 \u2139\ufe0f Working with dates For use in HTTP, you may format any date using the GMT time zone and the exact format as given above. While UTC and GMT are often used interchangeably, the HTTP specs require dates to be formatted in GMT. // convert date to GMT first, both forms are equivalent $modified = gmdate('D, d M Y H:i:s T', $date->getTimestamp()); $modified = $date->setTimezone(new DateTimeZone('GMT'))->format('D, d M Y H:i:s T'); If you don't know the modification date for your response or don't want to expose this information, you may want to use ETag headers from the previous section instead. Output buffering \u00b6 PHP provides a number of functions that write directly to the output buffer instead of returning values: echo , print , printf() , vprintf() , etc. var_dump() , var_export() , print_r() , etc. readfile() , fpassthru() , passthru() , etc. \u2026 These functions can also be used in X, but do require some special care because we want to redirect this output to be part of an HTTP response instead. You can start a temporary output buffer using ob_start() to catch any output and return it as a response body like this: public/index.php <?php // \u2026 $app -> get ( '/dump' , function () { ob_start (); echo \"Hello \\n \" ; var_dump ( 42 ); $body = ob_get_clean (); return React\\Http\\Message\\Response :: plaintext ( $body ); }); You can try out this example by sending an HTTP request like this: $ curl http://localhost:8080/dump Hello int ( 42 ) \u2139\ufe0f A word of caution Special care should be taken if the code in question is deeply nested with multiple return conditions or may throw an Exception . As a rule of thumb, output buffering should only be used as a last resort and directly working with string values is usually preferable. For instance, print_r() , var_export() and others accept optional boolean flags to return the value instead of printing to the output buffer. In many other cases, PHP also provides alternative functions that directly return string values instead of writing to the output buffer. For instance, instead of using printf() , you may want to use sprintf() . Internal Server Error \u00b6 Each controller function needs to return a response object in order to send an HTTP response message. If the controller function throws an Exception (or Throwable ) or returns any invalid type, the HTTP request will automatically be rejected with a 500 Internal Server Error HTTP error response: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { throw new BadMethodCallException (); }); You can try out this example by sending an HTTP request like this: $ curl -I http://localhost:8080/user HTTP/1.1 500 Internal Server Error \u2026 This default error handling can be configured through the App . See error handling for more details.","title":"Response"},{"location":"api/response/#response","text":"Whenever the client sends an HTTP request to our application, we need to send back an HTTP response message. We love standards and want to make using X as simple as possible. That's why we build on top of the established PSR-7 standard (HTTP message interfaces). This standard defines common interfaces for HTTP request and response objects. If you've ever used PSR-7 before, you should immediately feel at home when using X. If you're new to PSR-7, don't worry. Here's everything you need to know to get started. \u2139\ufe0f A note about other PSR-7 implementations All of the examples in this documentation use the React\\Http\\Message\\Response class because this comes bundled as part of our dependencies. If you have more specific requirements or want to integrate this with an existing piece of code, you can use any response implementation as long as it implements the Psr\\Http\\Message\\ResponseInterface .","title":"Response"},{"location":"api/response/#json","text":"You can send JSON data as an HTTP response body like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { $data = [ [ 'name' => 'Alice' ], [ 'name' => 'Bob' ] ]; return React\\Http\\Message\\Response :: json ( $data ); }); This example returns a simple JSON response from some static data. In real-world applications, you may want to load this from a database . For common API usage, you may also want to receive a JSON request . You can try out this example by sending an HTTP request like this: $ curl http://localhost:8080/user [ { \"name\" : \"Alice\" } , { \"name\" : \"Bob\" } ] By default, the response will use the 200 OK status code and will automatically include an appropriate Content-Type: application/json response header, see also status codes and response headers below for more details. If you want more control over the response such as using custom JSON flags, you can also manually create a React\\Http\\Message\\Response object like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { $data = []; return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_OK , [ 'Content-Type' => 'application/json' ], json_encode ( $data , JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ) . \" \\n \" ); });","title":"JSON"},{"location":"api/response/#html","text":"You can send HTML data as an HTTP response body like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { $html = <<< HTML <h1>Hello Alice</h1> HTML ; return React\\Http\\Message\\Response :: html ( $html ); }); This example returns a simple HTML response from some static data. In real-world applications, you may want to load this from a database and perhaps use templates to render your HTML. You can try out this example by sending an HTTP request like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> By default, the response will use the 200 OK status code and will automatically include an appropriate Content-Type: text/html; charset=utf-8 response header, see also status codes and response headers below for more details. If you want more control over this behavior, you can also manually create a React\\Http\\Message\\Response object like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { $html = \"Hello W\u00f6rld! \\n \" ; return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_OK , [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); });","title":"HTML"},{"location":"api/response/#status-codes","text":"The json() and html() methods used above automatically use a 200 OK status code by default. You can assign status codes like this: public/index.php <?php // \u2026 $app -> get ( '/user/{id}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $id = $request -> getAttribute ( 'id' ); if ( $id === 'admin' ) { return React\\Http\\Message\\Response :: html ( \"Forbidden \\n \" ) -> withStatus ( React\\Http\\Message\\Response :: STATUS_FORBIDDEN ); } return React\\Http\\Message\\Response :: html ( \"Hello $id\\n \" ); }); You can try out this example by sending an HTTP request like this: $ curl -I http://localhost:8080/user/Alice HTTP/1.1 200 OK \u2026 $ curl -I http://localhost:8080/user/admin HTTP/1.1 403 Forbidden \u2026 Each HTTP response message contains a status code that describes whether the HTTP request has been successfully completed. Here's a list with some of the most common HTTP status codes: 200 OK 301 Moved Permanently 302 Found (previously 302 Temporary Redirect ) 304 Not Modified (see HTTP caching below) 403 Forbidden 404 Not Found 500 Internal Server Error \u2026 See list of HTTP status codes for more details. Each status code can be referenced by its matching status code constant name such as React\\Http\\Message\\Response::STATUS_OK or React\\Http\\Message\\Response::STATUS_NOT_FOUND or by its status code number.","title":"Status Codes"},{"location":"api/response/#headers","text":"The json() and html() methods used above automatically use an appropriate Content-Type response header by default. You can assign HTTP response headers like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { return React\\Http\\Message\\Response :: html ( \"Hello w\u00f6rld! \\n \" ) -> withHeader ( 'Cache-Control' , 'public' ); }); You can try out this example by sending an HTTP request like this: $ curl -I http://localhost:8080/user HTTP/1.1 200 OK Content-Type: text/html ; charset = utf-8 Cache-Control: public Hello w\u00f6rld! Each HTTP response message can contain an arbitrary number of response headers. Additionally, the application will automatically include default headers required by the HTTP protocol. It's not recommended to mess with these default headers unless you're sure you know what you're doing. If you want more control over this behavior, you can also manually create a React\\Http\\Message\\Response object like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_OK , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'public' ], \"Hello w\u00f6rld! \\n \" ); });","title":"Headers"},{"location":"api/response/#http-redirects","text":"To redirect incoming HTTP requests to a new location you can define your HTTP response like this: public/index.php <?php // \u2026 $app -> get ( '/blog.html' , function () { return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_FOUND , [ 'Location' => '/blog' ] ); }); Redirect responses have a status code in the 3xx range. Here's a list with some of the most common HTTP redirect status codes: 301 Moved Permanently 302 Found (previously 302 Temporary Redirect ) 303 See Other 307 Temporary Redirect 308 Permanent Redirect Each status code can be referenced by its matching status code constant name such as React\\Http\\Message\\Response::STATUS_MOVED_PERMANENTLY or React\\Http\\Message\\Response::STATUS_FOUND or by its status code number. The Location response header holds the URL to redirect to. When a Browser or a search engine crawler receives a redirect, they will automatically follow the new URL provided in the Location header. You can also use the redirect helper method for simpler use cases: public/index.php <?php // \u2026 $app -> redirect ( '/promo/reactphp' , 'https://reactphp.org/' );","title":"HTTP Redirects"},{"location":"api/response/#http-caching","text":"HTTP caching can be used to significantly improve the performance of web applications by reusing previously fetched resources. HTTP caching is a whole topic on its own, so this section only aims to give a basic overview of how you can leverage HTTP caches with X. For a more in-depth overview, we highly recommend MDN . HTTP supports caching for certain requests by default. In any but the most basic use cases, it's often a good idea to explicitly specify HTTP caching headers as part of the HTTP response to have more control over the freshness lifetime and revalidation behavior.","title":"HTTP caching"},{"location":"api/response/#cache-control","text":"The Cache-Control response header can be used to control caching of responses by browsers and shared caches such as proxies and CDNs. In its most basic form, you can use this response header to control the lifetime of a cached response like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { $html = <<< HTML <h1>Hello Alice</h1> HTML ; return new React\\Http\\Message\\Response :: html ( $html ) -> withHeader ( 'Cache-Control' , 'max-age=3600' ); }); You can try out this example by sending an HTTP request like this: $ curl -I http://localhost:8080/user HTTP/1.1 200 OK Cache-Control: max-age = 3600 \u2026","title":"Cache-Control"},{"location":"api/response/#etag","text":"The ETag response header can be used for conditional requests. This ensures the response body only needs to be transferred when it actually changes. For instance, you can build a hash (or some other arbitrary identifier) for your contents and check if it matches the incoming If-None-Match request header for subsequent requests. If both values match, you can send a 304 Not Modified response and omit the response body like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { // example body, would usually come from some kind of database $html = <<< HTML <h1>Hello Alice</h1> HTML ; $etag = '\"' . sha1 ( $html ) . '\"' ; if ( $request -> getHeaderLine ( 'If-None-Match' ) === $etag ) { return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_NOT_MODIFIED , [ 'Cache-Control' => 'max-age=0, must-revalidate' , 'ETag' => $etag ] ); } return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_OK , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'max-age=0, must-revalidate' , 'ETag' => $etag ], $html ); }); You can try out this example by sending an HTTP request like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> $ curl -I http://localhost:8080/user -H 'If-None-Match: \"87637b595ed5b32934c011dc6b33afb43f598865\"' HTTP/1.1 304 Not Modified Cache-Control: max-age = 0 , must-revalidate ETag: \"87637b595ed5b32934c011dc6b33afb43f598865\" \u2026","title":"ETag"},{"location":"api/response/#last-modified","text":"The Last-Modified response header can be used to signal when a response was last modified. Among others, this can be used to ensure the response body only needs to be transferred when it changes. For instance, you can store a timestamp or datetime for your contents and check if it matches the incoming If-Modified-Since request header for subsequent requests. If both values match, you can send a 304 Not Modified response and omit the response body like this: public/index.php <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { // example date and body, would usually come from some kind of database $date = new DateTimeImmutable ( '2021-11-06 13:31:04' , new DateTimeZone ( 'Europe/Berlin' ) ); $html = <<< HTML <h1>Hello Alice</h1> HTML ; $modified = gmdate ( 'D, d M Y H:i:s T' , $date -> getTimestamp ()); if ( $request -> getHeaderLine ( 'If-Modified-Since' ) === $modified ) { return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_NOT_MODIFIED , [ 'Cache-Control' => 'max-age=0, must-revalidate' , 'Last-Modified' => $modified ] ); } return new React\\Http\\Message\\Response ( React\\Http\\Message\\Response :: STATUS_OK , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'max-age=0, must-revalidate' , 'Last-Modified' => $modified ], $html ); }); You can try out this example by sending an HTTP request like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> $ curl -I http://localhost:8080/user -H 'If-Modified-Since: Sat, 06 Nov 2021 12:31:04 GMT' HTTP/1.1 304 Not Modified Cache-Control: max-age = 0 , must-revalidate Last-Modified: Sat, 06 Nov 2021 12 :31:04 GMT \u2026 \u2139\ufe0f Working with dates For use in HTTP, you may format any date using the GMT time zone and the exact format as given above. While UTC and GMT are often used interchangeably, the HTTP specs require dates to be formatted in GMT. // convert date to GMT first, both forms are equivalent $modified = gmdate('D, d M Y H:i:s T', $date->getTimestamp()); $modified = $date->setTimezone(new DateTimeZone('GMT'))->format('D, d M Y H:i:s T'); If you don't know the modification date for your response or don't want to expose this information, you may want to use ETag headers from the previous section instead.","title":"Last-Modified"},{"location":"api/response/#output-buffering","text":"PHP provides a number of functions that write directly to the output buffer instead of returning values: echo , print , printf() , vprintf() , etc. var_dump() , var_export() , print_r() , etc. readfile() , fpassthru() , passthru() , etc. \u2026 These functions can also be used in X, but do require some special care because we want to redirect this output to be part of an HTTP response instead. You can start a temporary output buffer using ob_start() to catch any output and return it as a response body like this: public/index.php <?php // \u2026 $app -> get ( '/dump' , function () { ob_start (); echo \"Hello \\n \" ; var_dump ( 42 ); $body = ob_get_clean (); return React\\Http\\Message\\Response :: plaintext ( $body ); }); You can try out this example by sending an HTTP request like this: $ curl http://localhost:8080/dump Hello int ( 42 ) \u2139\ufe0f A word of caution Special care should be taken if the code in question is deeply nested with multiple return conditions or may throw an Exception . As a rule of thumb, output buffering should only be used as a last resort and directly working with string values is usually preferable. For instance, print_r() , var_export() and others accept optional boolean flags to return the value instead of printing to the output buffer. In many other cases, PHP also provides alternative functions that directly return string values instead of writing to the output buffer. For instance, instead of using printf() , you may want to use sprintf() .","title":"Output buffering"},{"location":"api/response/#internal-server-error","text":"Each controller function needs to return a response object in order to send an HTTP response message. If the controller function throws an Exception (or Throwable ) or returns any invalid type, the HTTP request will automatically be rejected with a 500 Internal Server Error HTTP error response: public/index.php <?php // \u2026 $app -> get ( '/user' , function () { throw new BadMethodCallException (); }); You can try out this example by sending an HTTP request like this: $ curl -I http://localhost:8080/user HTTP/1.1 500 Internal Server Error \u2026 This default error handling can be configured through the App . See error handling for more details.","title":"Internal Server Error"},{"location":"async/coroutines/","text":"Coroutines \u00b6 Coroutines allow consuming async APIs in a way that resembles a synchronous code flow. The yield keyword function can be used to \"await\" a promise or to \"unwrap\" its resolution value. Internally, this turns the entire function into a Generator which does affect the way return values need to be accessed. Quickstart \u00b6 Let's take a look at the most basic coroutine usage by using an async database integration with X: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { $result = yield $db -> query ( 'SELECT COUNT(*) AS count FROM book' ); $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); As you can see, using an async database adapter in X is very similar to using a normal, synchronous database adapter such as PDO. The only difference is how the $db->query() call returns a promise that we use the yield keyword to get the return value. Requirements \u00b6 X provides support for Generator-based coroutines out of the box, so there's nothing special you have to install. This works across all supported PHP versions. Usage \u00b6 Generator-based coroutines are very easy to use in X. The gist is that when X calls your controller function and you're working with an async API that returns a promise, you simply use the yield keyword on it in order to \"await\" its value or to \"unwrap\" its resolution value. Internally, this turns the entire function into a Generator which X can handle by consuming the generator. This is best shown in a simple example: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { $result = yield $db -> query ( 'SELECT COUNT(*) AS count FROM book' ); $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); In simple use cases such as above, Generated-based coroutines allow consuming async APIs in a way that resembles a synchronous code flow. However, using coroutines internally in some API means you have to return a Generator or promise as a return value, so the calling side needs to know how to handle an async API. This can be seen when breaking the above function up into a BookLookupController and a BookRepository . Let's start by creating the BookRepository which consumes our async database API: src/BookRepository.php <?php namespace Acme\\Todo ; use React\\MySQL\\ConnectionInterface ; use React\\MySQL\\QueryResult ; use React\\Promise\\PromiseInterface ; class BookRepository { private $db ; public function __construct ( ConnectionInterface $db ) { $this -> db = $db ; } /** @return \\Generator<mixed,PromiseInterface,mixed,?Book> **/ public function findBook ( string $isbn ) : \\Generator { $result = yield $this -> db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ); assert ( $result instanceof QueryResult ); if ( count ( $result -> resultRows ) === 0 ) { return null ; } return new Book ( $result -> resultRows [ 0 ][ 'title' ]); } } Likewise, the BookLookupController consumes the API of the BookRepository by using the yield from keyword: src/BookLookupController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; use React\\Promise\\PromiseInterface ; class BookLookupController { private $repository ; public function __construct ( BookRepository $repository ) { $this -> repository = $repository ; } /** @return \\Generator<mixed,PromiseInterface,mixed,ResponseInterface> **/ public function __invoke ( ServerRequestInterface $request ) : \\Generator { $isbn = $request -> getAttribute ( 'isbn' ); $book = yield from $this -> repository -> findBook ( $isbn ); assert ( $book === null || $book instanceof Book ); if ( $book === null ) { return Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( Response :: STATUS_NOT_FOUND ); } $data = $book -> title ; return Response :: plaintext ( $data ); } } As we can see, both classes need to return a Generator and the calling side in turn needs to handle this. This is all taken care of by X automatically when you use the yield statement anywhere in your controller function. See also async database APIs for more details. FAQ \u00b6 When to use coroutines? \u00b6 As a rule of thumb, you'll likely want to use coroutines when you're working with async APIs in your controllers with PHP < 8.1 and want to use these async APIs in a way that resembles a synchronous code flow. We also provide support for fibers which can be seen as an additional improvement as it allows you to use async APIs that look just like their synchronous counterparts. This makes them much easier to integrate and there's hope this will foster an even larger async ecosystem in the future. Additionally, we also provide support for promises on all supported PHP versions as an alternative. You can directly use promises as a core building block used in all our async APIs for maximum performance. How do coroutines work? \u00b6 Generator-based coroutines build on top of PHP's Generator class that will be used automatically whenever you use the yield keyword. Internally, we can turn this Generator return value into an async promise automatically. Whenever the Generator yields a value, we check it's a promise, await its resolution, and then send the resolution value back into the Generator , effectively resuming the operation on the same line. From your perspective, this means you yield an async promise and the yield returns a synchronous value (at a later time). Because promise resolution is usually async, so is \"awaiting\" a promise from your perspective, or advancing the Generator from our perspective. See also the coroutine() function for details.","title":"Coroutines"},{"location":"async/coroutines/#coroutines","text":"Coroutines allow consuming async APIs in a way that resembles a synchronous code flow. The yield keyword function can be used to \"await\" a promise or to \"unwrap\" its resolution value. Internally, this turns the entire function into a Generator which does affect the way return values need to be accessed.","title":"Coroutines"},{"location":"async/coroutines/#quickstart","text":"Let's take a look at the most basic coroutine usage by using an async database integration with X: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { $result = yield $db -> query ( 'SELECT COUNT(*) AS count FROM book' ); $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); As you can see, using an async database adapter in X is very similar to using a normal, synchronous database adapter such as PDO. The only difference is how the $db->query() call returns a promise that we use the yield keyword to get the return value.","title":"Quickstart"},{"location":"async/coroutines/#requirements","text":"X provides support for Generator-based coroutines out of the box, so there's nothing special you have to install. This works across all supported PHP versions.","title":"Requirements"},{"location":"async/coroutines/#usage","text":"Generator-based coroutines are very easy to use in X. The gist is that when X calls your controller function and you're working with an async API that returns a promise, you simply use the yield keyword on it in order to \"await\" its value or to \"unwrap\" its resolution value. Internally, this turns the entire function into a Generator which X can handle by consuming the generator. This is best shown in a simple example: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { $result = yield $db -> query ( 'SELECT COUNT(*) AS count FROM book' ); $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); In simple use cases such as above, Generated-based coroutines allow consuming async APIs in a way that resembles a synchronous code flow. However, using coroutines internally in some API means you have to return a Generator or promise as a return value, so the calling side needs to know how to handle an async API. This can be seen when breaking the above function up into a BookLookupController and a BookRepository . Let's start by creating the BookRepository which consumes our async database API: src/BookRepository.php <?php namespace Acme\\Todo ; use React\\MySQL\\ConnectionInterface ; use React\\MySQL\\QueryResult ; use React\\Promise\\PromiseInterface ; class BookRepository { private $db ; public function __construct ( ConnectionInterface $db ) { $this -> db = $db ; } /** @return \\Generator<mixed,PromiseInterface,mixed,?Book> **/ public function findBook ( string $isbn ) : \\Generator { $result = yield $this -> db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ); assert ( $result instanceof QueryResult ); if ( count ( $result -> resultRows ) === 0 ) { return null ; } return new Book ( $result -> resultRows [ 0 ][ 'title' ]); } } Likewise, the BookLookupController consumes the API of the BookRepository by using the yield from keyword: src/BookLookupController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; use React\\Promise\\PromiseInterface ; class BookLookupController { private $repository ; public function __construct ( BookRepository $repository ) { $this -> repository = $repository ; } /** @return \\Generator<mixed,PromiseInterface,mixed,ResponseInterface> **/ public function __invoke ( ServerRequestInterface $request ) : \\Generator { $isbn = $request -> getAttribute ( 'isbn' ); $book = yield from $this -> repository -> findBook ( $isbn ); assert ( $book === null || $book instanceof Book ); if ( $book === null ) { return Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( Response :: STATUS_NOT_FOUND ); } $data = $book -> title ; return Response :: plaintext ( $data ); } } As we can see, both classes need to return a Generator and the calling side in turn needs to handle this. This is all taken care of by X automatically when you use the yield statement anywhere in your controller function. See also async database APIs for more details.","title":"Usage"},{"location":"async/coroutines/#faq","text":"","title":"FAQ"},{"location":"async/coroutines/#when-to-use-coroutines","text":"As a rule of thumb, you'll likely want to use coroutines when you're working with async APIs in your controllers with PHP < 8.1 and want to use these async APIs in a way that resembles a synchronous code flow. We also provide support for fibers which can be seen as an additional improvement as it allows you to use async APIs that look just like their synchronous counterparts. This makes them much easier to integrate and there's hope this will foster an even larger async ecosystem in the future. Additionally, we also provide support for promises on all supported PHP versions as an alternative. You can directly use promises as a core building block used in all our async APIs for maximum performance.","title":"When to use coroutines?"},{"location":"async/coroutines/#how-do-coroutines-work","text":"Generator-based coroutines build on top of PHP's Generator class that will be used automatically whenever you use the yield keyword. Internally, we can turn this Generator return value into an async promise automatically. Whenever the Generator yields a value, we check it's a promise, await its resolution, and then send the resolution value back into the Generator , effectively resuming the operation on the same line. From your perspective, this means you yield an async promise and the yield returns a synchronous value (at a later time). Because promise resolution is usually async, so is \"awaiting\" a promise from your perspective, or advancing the Generator from our perspective. See also the coroutine() function for details.","title":"How do coroutines work?"},{"location":"async/fibers/","text":"Fibers \u00b6 Fibers allow consuming async APIs using a synchronous code flow. The await() function can be used to \"await\" a promise or to \"unwrap\" its resolution value. Fibers are a core ingredient of PHP 8.1+, but the same syntax also works on older PHP versions to some degree if you only have limited concurrency. Quickstart \u00b6 Let's take a look at the most basic fiber usage by using an async database integration with X: public/index.php <?php use function React\\Async\\await ; require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { $result = await ( $db -> query ( 'SELECT COUNT(*) AS count FROM book' )); $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); As you can see, using an async database adapter in X is very similar to using a normal, synchronous database adapter such as PDO. The only difference is how the $db->query() call returns a promise that we call await() on to get the return value. Requirements \u00b6 X provides support for fibers out of the box, so there's nothing special you have to install. You wouldn't usually have to directly interface with fibers, but the underlying APIs are provided thanks to the common reactphp/async package. Fibers are a core ingredient of PHP 8.1+ (released 2021-11-25), but the same syntax also works on older PHP versions to some degree if you only have limited concurrency. For production usage, we highly recommend using PHP 8.1+. \u26a0\ufe0f Compatibility mode For production usage, we highly recommend using PHP 8.1+. If you're using the await() function in compatibility mode with older PHP versions, it may stop the loop from running and may print a warning like this: Warning: Loop restarted. Upgrade to react/async v4 recommended [\u2026] Internally, the compatibility mode will cause recursive loop executions when dealing with concurrent requests. This should work fine for development purposes and fast controllers with low concurrency, but may cause issues in production with high concurrency. We understand that adoption of this very new PHP version is going to take some time and we acknowledge that this is probably one of the largest limitations of using fibers at the moment for many. We're committed to providing long-term support (LTS) options and providing a smooth upgrade path. As such, we also provide limited support for older PHP versions using a compatible API without taking advantage of newer language features. This way, you have a much smoother upgrade path, as you can already start using the future API for testing and development purposes and upgrade your PHP version for production use at a later time. Usage \u00b6 Fibers are very easy to use \u2013 because you simply can't see them \u2013 which in turn makes them a bit harder to explain. The gist is that whenever you're working with an async API that returns a promise, you simply call the await() function on it in order to \"await\" its value or to \"unwrap\" its resolution value. Fibers are an internal implementation detail provided by react/async , so you can simply rely on the await() function: <?php use function React\\Async\\await ; // \u2026 $browser = new React\\Http\\Browser (); $promise = $browser -> get ( 'https://example.com/' ); try { $response = await ( $promise ); assert ( $response instanceof Psr\\Http\\Message\\ResponseInterface ); echo $response -> getBody (); } catch ( Exception $e ) { echo 'Error: ' . $e -> getMessage () . PHP_EOL ; } See await() documentation for more details. \u2139\ufe0f Fibers vs. coroutines In simple use cases, fibers provide the exact same functionality also offered by Generator-based coroutines . However, using coroutines internally in some API means you have to return a Generator or promise as a return value, so the calling side needs to know how to handle an async API. This can make integration in larger applications harder. Fibers on the other hand are entirely opaque to the calling side. In simple words, this means there's nothing special you have to take care of when using fibers anywhere in your APIs. FAQ \u00b6 When to use fibers? \u00b6 As a rule of thumb, you'll likely want to use fibers when you have PHP 8.1+ available and want to use async APIs that look just like their synchronous counterparts. This makes them much easier to integrate and there's hope this will foster a larger ecosystem in the future. We also provide support for coroutines and promises on all supported PHP versions as an alternative. Coroutines allow consuming async APIs in a way that resembles a synchronous code flow using the yield keyword. You can also directly use promises as a core building block used in all our async APIs for maximum performance. How do fibers work? \u00b6 Fibers are a means of creating code blocks that can be paused and resumed, but the details are a bit more involved. For more details, see our blog post .","title":"Fibers"},{"location":"async/fibers/#fibers","text":"Fibers allow consuming async APIs using a synchronous code flow. The await() function can be used to \"await\" a promise or to \"unwrap\" its resolution value. Fibers are a core ingredient of PHP 8.1+, but the same syntax also works on older PHP versions to some degree if you only have limited concurrency.","title":"Fibers"},{"location":"async/fibers/#quickstart","text":"Let's take a look at the most basic fiber usage by using an async database integration with X: public/index.php <?php use function React\\Async\\await ; require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { $result = await ( $db -> query ( 'SELECT COUNT(*) AS count FROM book' )); $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); As you can see, using an async database adapter in X is very similar to using a normal, synchronous database adapter such as PDO. The only difference is how the $db->query() call returns a promise that we call await() on to get the return value.","title":"Quickstart"},{"location":"async/fibers/#requirements","text":"X provides support for fibers out of the box, so there's nothing special you have to install. You wouldn't usually have to directly interface with fibers, but the underlying APIs are provided thanks to the common reactphp/async package. Fibers are a core ingredient of PHP 8.1+ (released 2021-11-25), but the same syntax also works on older PHP versions to some degree if you only have limited concurrency. For production usage, we highly recommend using PHP 8.1+. \u26a0\ufe0f Compatibility mode For production usage, we highly recommend using PHP 8.1+. If you're using the await() function in compatibility mode with older PHP versions, it may stop the loop from running and may print a warning like this: Warning: Loop restarted. Upgrade to react/async v4 recommended [\u2026] Internally, the compatibility mode will cause recursive loop executions when dealing with concurrent requests. This should work fine for development purposes and fast controllers with low concurrency, but may cause issues in production with high concurrency. We understand that adoption of this very new PHP version is going to take some time and we acknowledge that this is probably one of the largest limitations of using fibers at the moment for many. We're committed to providing long-term support (LTS) options and providing a smooth upgrade path. As such, we also provide limited support for older PHP versions using a compatible API without taking advantage of newer language features. This way, you have a much smoother upgrade path, as you can already start using the future API for testing and development purposes and upgrade your PHP version for production use at a later time.","title":"Requirements"},{"location":"async/fibers/#usage","text":"Fibers are very easy to use \u2013 because you simply can't see them \u2013 which in turn makes them a bit harder to explain. The gist is that whenever you're working with an async API that returns a promise, you simply call the await() function on it in order to \"await\" its value or to \"unwrap\" its resolution value. Fibers are an internal implementation detail provided by react/async , so you can simply rely on the await() function: <?php use function React\\Async\\await ; // \u2026 $browser = new React\\Http\\Browser (); $promise = $browser -> get ( 'https://example.com/' ); try { $response = await ( $promise ); assert ( $response instanceof Psr\\Http\\Message\\ResponseInterface ); echo $response -> getBody (); } catch ( Exception $e ) { echo 'Error: ' . $e -> getMessage () . PHP_EOL ; } See await() documentation for more details. \u2139\ufe0f Fibers vs. coroutines In simple use cases, fibers provide the exact same functionality also offered by Generator-based coroutines . However, using coroutines internally in some API means you have to return a Generator or promise as a return value, so the calling side needs to know how to handle an async API. This can make integration in larger applications harder. Fibers on the other hand are entirely opaque to the calling side. In simple words, this means there's nothing special you have to take care of when using fibers anywhere in your APIs.","title":"Usage"},{"location":"async/fibers/#faq","text":"","title":"FAQ"},{"location":"async/fibers/#when-to-use-fibers","text":"As a rule of thumb, you'll likely want to use fibers when you have PHP 8.1+ available and want to use async APIs that look just like their synchronous counterparts. This makes them much easier to integrate and there's hope this will foster a larger ecosystem in the future. We also provide support for coroutines and promises on all supported PHP versions as an alternative. Coroutines allow consuming async APIs in a way that resembles a synchronous code flow using the yield keyword. You can also directly use promises as a core building block used in all our async APIs for maximum performance.","title":"When to use fibers?"},{"location":"async/fibers/#how-do-fibers-work","text":"Fibers are a means of creating code blocks that can be paused and resumed, but the details are a bit more involved. For more details, see our blog post .","title":"How do fibers work?"},{"location":"async/promises/","text":"Promises \u00b6 Promises are a core building block used in all our async APIs. They are especially useful if want to express a concurrent code flow. You can directly use their API for maximum performance or use Fibers or Coroutines as an easier way to work with async APIs. Quickstart \u00b6 Let's take a look at the most basic promise usage by using an async database integration with X: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { return $db -> query ( 'SELECT COUNT(*) AS count FROM book' ) -> then ( function ( React\\MySQL\\QueryResult $result ) { $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); }); $app -> run () : As you can see, using an async database adapter in X with its promise-based API is similar to using a normal, synchronous database adapter such as PDO. The major difference is how the $db->query() call returns a promise that we use a chained then() call on to get its fulfillment value. Requirements \u00b6 X provides support for promises out of the box, so there's nothing special you have to install. If you've used promises before, you'll find a common API for promises in PHP thanks to reactphp/promise . This works across all supported PHP versions. Usage \u00b6 If you've used promises before, you'll find that using promise-based APIs in X is pretty straightforward. The gist is that when you're working with an async API that returns a promise, you have to use a chained then() call on it in order to \"await\" its fulfillment value. This is best shown in a simple example: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { return $db -> query ( 'SELECT COUNT(*) AS count FROM book' ) -> then ( function ( React\\MySQL\\QueryResult $result ) { $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); }); $app -> run () : Even in simple use cases such as above, promise-based APIs can take some time to get used to. At the same time, promise-based abstractions are one of the most efficient ways to express asynchronous APIs and as such are used throughout X and ReactPHP's ecosystem. One of the most obvious consequences of using promises for async APIs is that it requires the calling side to know how to handle an async API. This can be seen when breaking the above function up into a BookLookupController and a BookRepository . Let's start by creating the BookRepository which consumes our async database API: src/BookRepository.php <?php namespace Acme\\Todo ; use React\\MySQL\\ConnectionInterface ; use React\\MySQL\\QueryResult ; use React\\Promise\\PromiseInterface ; class BookRepository { private $db ; public function __construct ( ConnectionInterface $db ) { $this -> db = $db ; } /** @return PromiseInterface<?Book> **/ public function findBook ( string $isbn ) : PromiseInterface { return $this -> db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ) -> then ( function ( QueryResult $result ) { if ( count ( $result -> resultRows ) === 0 ) { return null ; } return new Book ( $result -> resultRows [ 0 ][ 'title' ]); }); } } Likewise, the BookLookupController consumes the API of the BookRepository by again using its promise-based API: src/BookLookupController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; use React\\Promise\\PromiseInterface ; class BookLookupController { private $repository ; public function __construct ( BookRepository $repository ) { $this -> repository = $repository ; } /** @return PromiseInterface<ResponseInterface> **/ public function __invoke ( ServerRequestInterface $request ) : PromiseInterface { $isbn = $request -> getAttribute ( 'isbn' ); return $this -> repository -> findBook ( $isbn ) -> then ( function ( ? Book $book ) { if ( $book === null ) { return Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( Response :: STATUS_NOT_FOUND ); } $data = $book -> title ; return Response :: plaintext ( $data ); }); } } As we can see, both classes need to return a promise and the calling side in turn needs to handle this. This is all taken care of by X automatically when you use promises anywhere in your controller function. See also async database APIs for more details. FAQ \u00b6 When to use promises? \u00b6 As a rule of thumb, promise-based APIs are one of the most efficient ways to express asynchronous APIs and as such are used throughout X and ReactPHP's ecosystem. You can always use promises as a core building block for async APIs for maximum performance. At the same time, using fibers and coroutines is often much easier as it allows consuming async APIs in a way that resembles a synchronous code flow. Both build on top of promises, so there's a fair chance you'll end up using promises one way or another no matter what. The major feature is that this means that anything that takes some time will no longer block the entire execution. These non-blocking operations are especially beneficial for anything that incurs some kind of I/O , such as database queries , HTTP API requests, filesystem access and much more. If you want to learn more about the promise API, see also reactphp/promise . How do promises work? \u00b6 If you want to learn more about the promise API, see also reactphp/promise .","title":"Promises"},{"location":"async/promises/#promises","text":"Promises are a core building block used in all our async APIs. They are especially useful if want to express a concurrent code flow. You can directly use their API for maximum performance or use Fibers or Coroutines as an easier way to work with async APIs.","title":"Promises"},{"location":"async/promises/#quickstart","text":"Let's take a look at the most basic promise usage by using an async database integration with X: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { return $db -> query ( 'SELECT COUNT(*) AS count FROM book' ) -> then ( function ( React\\MySQL\\QueryResult $result ) { $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); }); $app -> run () : As you can see, using an async database adapter in X with its promise-based API is similar to using a normal, synchronous database adapter such as PDO. The major difference is how the $db->query() call returns a promise that we use a chained then() call on to get its fulfillment value.","title":"Quickstart"},{"location":"async/promises/#requirements","text":"X provides support for promises out of the box, so there's nothing special you have to install. If you've used promises before, you'll find a common API for promises in PHP thanks to reactphp/promise . This works across all supported PHP versions.","title":"Requirements"},{"location":"async/promises/#usage","text":"If you've used promises before, you'll find that using promise-based APIs in X is pretty straightforward. The gist is that when you're working with an async API that returns a promise, you have to use a chained then() call on it in order to \"await\" its fulfillment value. This is best shown in a simple example: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { return $db -> query ( 'SELECT COUNT(*) AS count FROM book' ) -> then ( function ( React\\MySQL\\QueryResult $result ) { $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); }); $app -> run () : Even in simple use cases such as above, promise-based APIs can take some time to get used to. At the same time, promise-based abstractions are one of the most efficient ways to express asynchronous APIs and as such are used throughout X and ReactPHP's ecosystem. One of the most obvious consequences of using promises for async APIs is that it requires the calling side to know how to handle an async API. This can be seen when breaking the above function up into a BookLookupController and a BookRepository . Let's start by creating the BookRepository which consumes our async database API: src/BookRepository.php <?php namespace Acme\\Todo ; use React\\MySQL\\ConnectionInterface ; use React\\MySQL\\QueryResult ; use React\\Promise\\PromiseInterface ; class BookRepository { private $db ; public function __construct ( ConnectionInterface $db ) { $this -> db = $db ; } /** @return PromiseInterface<?Book> **/ public function findBook ( string $isbn ) : PromiseInterface { return $this -> db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ) -> then ( function ( QueryResult $result ) { if ( count ( $result -> resultRows ) === 0 ) { return null ; } return new Book ( $result -> resultRows [ 0 ][ 'title' ]); }); } } Likewise, the BookLookupController consumes the API of the BookRepository by again using its promise-based API: src/BookLookupController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; use React\\Promise\\PromiseInterface ; class BookLookupController { private $repository ; public function __construct ( BookRepository $repository ) { $this -> repository = $repository ; } /** @return PromiseInterface<ResponseInterface> **/ public function __invoke ( ServerRequestInterface $request ) : PromiseInterface { $isbn = $request -> getAttribute ( 'isbn' ); return $this -> repository -> findBook ( $isbn ) -> then ( function ( ? Book $book ) { if ( $book === null ) { return Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( Response :: STATUS_NOT_FOUND ); } $data = $book -> title ; return Response :: plaintext ( $data ); }); } } As we can see, both classes need to return a promise and the calling side in turn needs to handle this. This is all taken care of by X automatically when you use promises anywhere in your controller function. See also async database APIs for more details.","title":"Usage"},{"location":"async/promises/#faq","text":"","title":"FAQ"},{"location":"async/promises/#when-to-use-promises","text":"As a rule of thumb, promise-based APIs are one of the most efficient ways to express asynchronous APIs and as such are used throughout X and ReactPHP's ecosystem. You can always use promises as a core building block for async APIs for maximum performance. At the same time, using fibers and coroutines is often much easier as it allows consuming async APIs in a way that resembles a synchronous code flow. Both build on top of promises, so there's a fair chance you'll end up using promises one way or another no matter what. The major feature is that this means that anything that takes some time will no longer block the entire execution. These non-blocking operations are especially beneficial for anything that incurs some kind of I/O , such as database queries , HTTP API requests, filesystem access and much more. If you want to learn more about the promise API, see also reactphp/promise .","title":"When to use promises?"},{"location":"async/promises/#how-do-promises-work","text":"If you want to learn more about the promise API, see also reactphp/promise .","title":"How do promises work?"},{"location":"best-practices/controllers/","text":"Controller classes \u00b6 First steps \u00b6 When starting with X, it's often easiest to start with simple closure definitions like suggested in the quickstart guide . As a next step, let's take a look at how this structure can be improved with controller classes. This is especially useful once you leave the prototyping phase and want to find the best structure for a production-ready setup. To get started, let's take a look at the following simple closure definitions: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , function () { return React\\Http\\Message\\Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); }); $app -> get ( '/users/{name}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { return React\\Http\\Message\\Response :: plaintext ( \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); }); $app -> run (); While easy to get started, it's also easy to see how this will get out of hand for more complex business domains when you have more than a couple of routes registered. For real-world applications, we highly recommend structuring your application into individual controller classes. This way, we can break up the above definition into three even simpler files: Using controller instances Using controller names public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , new Acme\\Todo\\HelloController ()); $app -> get ( '/users/{name}' , new Acme\\Todo\\UserController ()); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , Acme\\Todo\\HelloController :: class ); $app -> get ( '/users/{name}' , Acme\\Todo\\UserController :: class ); $app -> run (); src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); } } src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { return Response :: plaintext ( \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); } } Composer autoloading \u00b6 Doesn't look too complex, right? Now, we only need to tell Composer's autoloader about our vendor namespace Acme\\Todo in the src/ folder. Make sure to include the following lines in your composer.json file: composer.json { \"autoload\" : { \"psr-4\" : { \"Acme\\\\Todo\\\\\" : \"src/\" } } } When we're doing this the first time, we have to update Composer's generated autoloader classes: $ composer dump-autoload \u2139\ufe0f New to Composer? Don't worry, that's a one-time setup only. If you're used to working with Composer, this shouldn't be too surprising. If this sounds new to you, rest assured this is the only time you have to worry about this, new classes can simply be added without having to run Composer again. Again, let's see our web application still works by using your favorite web browser or command-line tool: $ curl http://localhost:8080/ Hello w\u00f6rld! If everything works as expected, we can continue with writing our first tests to automate this. Container \u00b6 X has a powerful, built-in dependency injection container (DI container or DIC). It allows you to automatically create request handler classes and their dependencies with zero configuration for most common use cases. \u2139\ufe0f Dependency Injection (DI) Dependency injection (DI) is a technique in which an object receives other objects that it depends on, rather than creating these dependencies within its class. In its most basic form, this means creating all required object dependencies upfront and manually injecting them into the controller class. This can be done manually or you can use the optional container which does this for you. Autowiring \u00b6 To use autowiring, simply pass in the class name of your request handler classes like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , Acme\\Todo\\HelloController :: class ); $app -> get ( '/users/{name}' , Acme\\Todo\\UserController :: class ); $app -> run (); X will automatically take care of instantiating the required request handler classes and their dependencies when a request comes in. This autowiring feature covers most common use cases: Names always reference existing class names. Class names need to be loadable through the autoloader. See composer autoloading above. Each class may or may not have a constructor. If the constructor has an optional argument, it will be omitted unless an explicit container configuration is used. If the constructor has a nullable argument, it will be given a null value unless an explicit container configuration is used. If the constructor references another class, it will load this class next. This covers most common use cases where the request handler class uses a constructor with type definitions to explicitly reference other classes. Container configuration \u00b6 Autowiring should cover most common use cases with zero configuration. If you want to have more control over this behavior, you may also explicitly configure the dependency injection container like this: Arrow functions (PHP 7.4+) Closure public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\HelloController :: class => fn () => new Acme\\Todo\\HelloController () ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\HelloController :: class => function () { return new Acme\\Todo\\HelloController (); } ]); $app = new FrameworkX\\App ( $container ); // \u2026 This can be useful in these cases: Constructor parameter references an interface and you want to explicitly define an instance that implements this interface. Constructor parameter has a primitive type (scalars such as int or string etc.) or has no type at all and you want to explicitly bind a given value. Constructor parameter references a class, but you want to inject a specific instance or subclass in place of a default class. The configured container instance can be passed into the application like any other middleware request handler. In most cases this means you create a single Container instance with a number of factory functions and pass this instance as the first argument to the App . In its most common form, each entry in the container configuration maps a class name to a factory function that will be invoked when this class is first requested. The factory function is responsible for returning an instance that implements the given class name. Factory functions used in the container configuration map may reference other classes that will automatically be injected from the container. This can be particularly useful when combining autowiring with some manual configuration like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\UserController :: class => function ( React\\Http\\Browser $browser ) { // example UserController class requires two arguments: // - first argument will be autowired based on class reference // - second argument expects some manual value return new Acme\\Todo\\UserController ( $browser , 42 ); } ]); $app = new FrameworkX\\App ( $container ); // \u2026 Factory functions used in the container configuration map may also reference variables defined in the container configuration. You may use any object or scalar or null value for container variables or factory functions that return any such value. This can be particularly useful when combining autowiring with some manual configuration like this: Scalar values Default values Nullable values public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\UserController :: class => function ( bool $debug , string $hostname ) { // example UserController class uses two container variables return new Acme\\Todo\\UserController ( $debug , $hostname ); }, 'debug' => false , 'hostname' => fn () : string => gethostname () ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\UserController :: class => function ( bool $debug = false ) { // example UserController class uses $debug, apply default if not set return new Acme\\Todo\\UserController ( $debug ); }, 'debug' => true ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\UserController :: class => function ( ? string $name ) { // example UserController class uses $name, defaults to null if not set return new Acme\\Todo\\UserController ( $name ?? 'ACME' ); }, 'name' => 'Demo' ]); $app = new FrameworkX\\App ( $container ); // \u2026 \u2139\ufe0f Avoiding name collisions Note that class names and container variables share the same container configuration map and as such might be subject to name collisions as a single entry may only have a single value. For this reason, container variables will only be used for container functions by default. We highly recommend using namespaced class names like in the previous example. You may also want to make sure that container variables use unique names prefixed with your vendor name. All environment variables will be made available as container variables automatically. You can access their values simply by referencing variables in all uppercase in any factory function like this: Required environment variables Optional environment variables Built-in environment variables public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ React\\MySQL\\ConnectionInterface :: class => function ( string $MYSQL_URI ) { // connect to database defined in required $MYSQL_URI environment variable return ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $MYSQL_URI ); } ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ React\\MySQL\\ConnectionInterface :: class => function ( string $DB_HOST = 'localhost' , string $DB_USER = 'root' , string $DB_PASS = '' , string $DB_NAME = 'acme' ) { // connect to database defined in optional $DB_* environment variables $uri = 'mysql://' . $DB_USER . ':' . rawurlencode ( $DB_PASS ) . '@' . $DB_HOST . '/' . $DB_NAME ; return ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $uri ); } ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ // Framework X also uses environment variables internally. // You may explicitly configure this built-in functionality like this: // 'X_LISTEN' => '0.0.0.0:8081' // 'X_LISTEN' => fn(?string $PORT = '8080') => '0.0.0.0:' . $PORT 'X_LISTEN' => '127.0.0.1:8080' ]); $app = new FrameworkX\\App ( $container ); // \u2026 \u2139\ufe0f Passing environment variables All environment variables defined on the process level will be made available automatically. For temporary testing purposes, you may explicitly export or prefix environment variables to the command line. As a more permanent solution, you may want to save your environment variables in your systemd configuration , Docker settings , or load your variables from a dotenv file ( .env ) using a library such as vlucas/phpdotenv . The container configuration may also be used to map a class name to a different class name that implements the same interface, either by mapping between two class names or using a factory function that returns a class name. This is particularly useful when implementing an interface. public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ React\\Cache\\CacheInterface :: class => React\\Cache\\ArrayCache :: class , Psr\\Http\\Message\\ResponseInterface :: class => function () { // returns class implementing interface from factory function return React\\Http\\Message\\Response :: class ; } ]); $app = new FrameworkX\\App ( $container ); // \u2026 PSR-11: Container interface \u00b6 X has a powerful, built-in dependency injection container (DI container or DIC) that has a strong focus on simplicity and should cover most common use cases. Sometimes, you might need a little more control over this and may want to use a custom container implementation instead. We love standards and interoperability, that's why we support the PSR-11: Container interface . This is a common interface that is used by most DI containers in PHP. In the following example, we're using PHP-DI , but you may likewise use any other implementation of this interface: composer require php-di/php-di In order to use an external DI container, you first have to instantiate your custom container as per its documentation. If this instance implements the Psr\\Container\\ContainerInterface , you can then pass it into the X container that acts as an adapter for the application like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; // $builder = new DI\\ContainerBuilder(); // $builder->\u2026 // $container = $builder->build(); $container = new DI\\Container (); $app = new FrameworkX\\App ( new FrameworkX\\Container ( $container )); // \u2026 We expect most applications to work just fine with the built-in DI container. If you need to use a custom container, the above logic should work with any of the PSR-11 container implementations .","title":"Controller classes"},{"location":"best-practices/controllers/#controller-classes","text":"","title":"Controller classes"},{"location":"best-practices/controllers/#first-steps","text":"When starting with X, it's often easiest to start with simple closure definitions like suggested in the quickstart guide . As a next step, let's take a look at how this structure can be improved with controller classes. This is especially useful once you leave the prototyping phase and want to find the best structure for a production-ready setup. To get started, let's take a look at the following simple closure definitions: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , function () { return React\\Http\\Message\\Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); }); $app -> get ( '/users/{name}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { return React\\Http\\Message\\Response :: plaintext ( \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); }); $app -> run (); While easy to get started, it's also easy to see how this will get out of hand for more complex business domains when you have more than a couple of routes registered. For real-world applications, we highly recommend structuring your application into individual controller classes. This way, we can break up the above definition into three even simpler files: Using controller instances Using controller names public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , new Acme\\Todo\\HelloController ()); $app -> get ( '/users/{name}' , new Acme\\Todo\\UserController ()); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , Acme\\Todo\\HelloController :: class ); $app -> get ( '/users/{name}' , Acme\\Todo\\UserController :: class ); $app -> run (); src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); } } src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { return Response :: plaintext ( \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); } }","title":"First steps"},{"location":"best-practices/controllers/#composer-autoloading","text":"Doesn't look too complex, right? Now, we only need to tell Composer's autoloader about our vendor namespace Acme\\Todo in the src/ folder. Make sure to include the following lines in your composer.json file: composer.json { \"autoload\" : { \"psr-4\" : { \"Acme\\\\Todo\\\\\" : \"src/\" } } } When we're doing this the first time, we have to update Composer's generated autoloader classes: $ composer dump-autoload \u2139\ufe0f New to Composer? Don't worry, that's a one-time setup only. If you're used to working with Composer, this shouldn't be too surprising. If this sounds new to you, rest assured this is the only time you have to worry about this, new classes can simply be added without having to run Composer again. Again, let's see our web application still works by using your favorite web browser or command-line tool: $ curl http://localhost:8080/ Hello w\u00f6rld! If everything works as expected, we can continue with writing our first tests to automate this.","title":"Composer autoloading"},{"location":"best-practices/controllers/#container","text":"X has a powerful, built-in dependency injection container (DI container or DIC). It allows you to automatically create request handler classes and their dependencies with zero configuration for most common use cases. \u2139\ufe0f Dependency Injection (DI) Dependency injection (DI) is a technique in which an object receives other objects that it depends on, rather than creating these dependencies within its class. In its most basic form, this means creating all required object dependencies upfront and manually injecting them into the controller class. This can be done manually or you can use the optional container which does this for you.","title":"Container"},{"location":"best-practices/controllers/#autowiring","text":"To use autowiring, simply pass in the class name of your request handler classes like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , Acme\\Todo\\HelloController :: class ); $app -> get ( '/users/{name}' , Acme\\Todo\\UserController :: class ); $app -> run (); X will automatically take care of instantiating the required request handler classes and their dependencies when a request comes in. This autowiring feature covers most common use cases: Names always reference existing class names. Class names need to be loadable through the autoloader. See composer autoloading above. Each class may or may not have a constructor. If the constructor has an optional argument, it will be omitted unless an explicit container configuration is used. If the constructor has a nullable argument, it will be given a null value unless an explicit container configuration is used. If the constructor references another class, it will load this class next. This covers most common use cases where the request handler class uses a constructor with type definitions to explicitly reference other classes.","title":"Autowiring"},{"location":"best-practices/controllers/#container-configuration","text":"Autowiring should cover most common use cases with zero configuration. If you want to have more control over this behavior, you may also explicitly configure the dependency injection container like this: Arrow functions (PHP 7.4+) Closure public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\HelloController :: class => fn () => new Acme\\Todo\\HelloController () ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\HelloController :: class => function () { return new Acme\\Todo\\HelloController (); } ]); $app = new FrameworkX\\App ( $container ); // \u2026 This can be useful in these cases: Constructor parameter references an interface and you want to explicitly define an instance that implements this interface. Constructor parameter has a primitive type (scalars such as int or string etc.) or has no type at all and you want to explicitly bind a given value. Constructor parameter references a class, but you want to inject a specific instance or subclass in place of a default class. The configured container instance can be passed into the application like any other middleware request handler. In most cases this means you create a single Container instance with a number of factory functions and pass this instance as the first argument to the App . In its most common form, each entry in the container configuration maps a class name to a factory function that will be invoked when this class is first requested. The factory function is responsible for returning an instance that implements the given class name. Factory functions used in the container configuration map may reference other classes that will automatically be injected from the container. This can be particularly useful when combining autowiring with some manual configuration like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\UserController :: class => function ( React\\Http\\Browser $browser ) { // example UserController class requires two arguments: // - first argument will be autowired based on class reference // - second argument expects some manual value return new Acme\\Todo\\UserController ( $browser , 42 ); } ]); $app = new FrameworkX\\App ( $container ); // \u2026 Factory functions used in the container configuration map may also reference variables defined in the container configuration. You may use any object or scalar or null value for container variables or factory functions that return any such value. This can be particularly useful when combining autowiring with some manual configuration like this: Scalar values Default values Nullable values public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\UserController :: class => function ( bool $debug , string $hostname ) { // example UserController class uses two container variables return new Acme\\Todo\\UserController ( $debug , $hostname ); }, 'debug' => false , 'hostname' => fn () : string => gethostname () ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\UserController :: class => function ( bool $debug = false ) { // example UserController class uses $debug, apply default if not set return new Acme\\Todo\\UserController ( $debug ); }, 'debug' => true ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ Acme\\Todo\\UserController :: class => function ( ? string $name ) { // example UserController class uses $name, defaults to null if not set return new Acme\\Todo\\UserController ( $name ?? 'ACME' ); }, 'name' => 'Demo' ]); $app = new FrameworkX\\App ( $container ); // \u2026 \u2139\ufe0f Avoiding name collisions Note that class names and container variables share the same container configuration map and as such might be subject to name collisions as a single entry may only have a single value. For this reason, container variables will only be used for container functions by default. We highly recommend using namespaced class names like in the previous example. You may also want to make sure that container variables use unique names prefixed with your vendor name. All environment variables will be made available as container variables automatically. You can access their values simply by referencing variables in all uppercase in any factory function like this: Required environment variables Optional environment variables Built-in environment variables public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ React\\MySQL\\ConnectionInterface :: class => function ( string $MYSQL_URI ) { // connect to database defined in required $MYSQL_URI environment variable return ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $MYSQL_URI ); } ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ React\\MySQL\\ConnectionInterface :: class => function ( string $DB_HOST = 'localhost' , string $DB_USER = 'root' , string $DB_PASS = '' , string $DB_NAME = 'acme' ) { // connect to database defined in optional $DB_* environment variables $uri = 'mysql://' . $DB_USER . ':' . rawurlencode ( $DB_PASS ) . '@' . $DB_HOST . '/' . $DB_NAME ; return ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $uri ); } ]); $app = new FrameworkX\\App ( $container ); // \u2026 public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ // Framework X also uses environment variables internally. // You may explicitly configure this built-in functionality like this: // 'X_LISTEN' => '0.0.0.0:8081' // 'X_LISTEN' => fn(?string $PORT = '8080') => '0.0.0.0:' . $PORT 'X_LISTEN' => '127.0.0.1:8080' ]); $app = new FrameworkX\\App ( $container ); // \u2026 \u2139\ufe0f Passing environment variables All environment variables defined on the process level will be made available automatically. For temporary testing purposes, you may explicitly export or prefix environment variables to the command line. As a more permanent solution, you may want to save your environment variables in your systemd configuration , Docker settings , or load your variables from a dotenv file ( .env ) using a library such as vlucas/phpdotenv . The container configuration may also be used to map a class name to a different class name that implements the same interface, either by mapping between two class names or using a factory function that returns a class name. This is particularly useful when implementing an interface. public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ React\\Cache\\CacheInterface :: class => React\\Cache\\ArrayCache :: class , Psr\\Http\\Message\\ResponseInterface :: class => function () { // returns class implementing interface from factory function return React\\Http\\Message\\Response :: class ; } ]); $app = new FrameworkX\\App ( $container ); // \u2026","title":"Container configuration"},{"location":"best-practices/controllers/#psr-11-container-interface","text":"X has a powerful, built-in dependency injection container (DI container or DIC) that has a strong focus on simplicity and should cover most common use cases. Sometimes, you might need a little more control over this and may want to use a custom container implementation instead. We love standards and interoperability, that's why we support the PSR-11: Container interface . This is a common interface that is used by most DI containers in PHP. In the following example, we're using PHP-DI , but you may likewise use any other implementation of this interface: composer require php-di/php-di In order to use an external DI container, you first have to instantiate your custom container as per its documentation. If this instance implements the Psr\\Container\\ContainerInterface , you can then pass it into the X container that acts as an adapter for the application like this: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; // $builder = new DI\\ContainerBuilder(); // $builder->\u2026 // $container = $builder->build(); $container = new DI\\Container (); $app = new FrameworkX\\App ( new FrameworkX\\Container ( $container )); // \u2026 We expect most applications to work just fine with the built-in DI container. If you need to use a custom container, the above logic should work with any of the PSR-11 container implementations .","title":"PSR-11: Container interface"},{"location":"best-practices/deployment/","text":"Production deployment \u00b6 One of the nice properties of X is that it runs anywhere , i.e. it works both behind traditional web server setups as well as in a stand-alone environment. This makes it easy to get started with existing web application stacks, yet it provides even more awesome features with its built-in web server. Traditional stacks \u00b6 No matter what existing PHP stack you're using, X runs anywhere. This means that if you've already used PHP before, X will just work . nginx or Caddy with PHP-FPM Apache with PHP-FPM, mod_fcgid, mod_cgi or mod_php Any other web server using FastCGI to talk to PHP-FPM Linux, Mac and Windows operating systems ( LAMP, MAMP, WAMP ) We've got you covered! PHP development web server \u00b6 For example, if you've followed the quickstart guide , you can run this using PHP's built-in development web server for testing purposes like this: $ php -S 0 .0.0.0:8080 public/index.php In order to check your web application responds as expected, you can use your favorite web browser or command-line tool: $ curl http://localhost:8080/ Hello w\u00f6rld! nginx \u00b6 nginx is a high performance web server, load balancer and reverse proxy. In particular, its high performance and versatility makes it one of the most popular web servers. It is used everywhere from the smallest projects to the biggest enterprises. X supports nginx out of the box. If you've used nginx before to run any PHP application, using nginx with X is as simple as dropping the project files in the right directory. Accordingly, this guide assumes you want to process a number of dynamic routes through X and optionally include some public assets (such as style sheets and images). \u2139\ufe0f PHP-FPM or reverse proxy? This section assumes you want to use nginx with PHP-FPM which is a very common, traditional web stack. If you want to get the most out of X, you may also want to look into using the built-in web server with an nginx reverse proxy . Assuming you've followed the quickstart guide , all you need to do is to point the nginx' root (\"docroot\") to the public/ directory of your project. On top of this, you'll need to instruct nginx to process any dynamic requests through X. This can be achieved by using an nginx configuration with the following contents: server { root /home/alice/projects/acme/public; index index.php index.html; location / { try_files $uri $uri/ /index.php$is_args$args; } # Optional: handle Apache config with Framework X if it exists in `public/` error_page 403 = /index.php; location ~ \\.htaccess$ { deny all; } location ~ \\.php$ { fastcgi_pass localhost:9000; fastcgi_split_path_info ^(.+\\.php)(/.+)$; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; } } \u2139\ufe0f New to nginx? A complete nginx configuration is out of scope for this guide, so we assume you already have nginx and PHP with PHP-FPM up and running. In this example, we're assuming PHP-FPM is already up and running and listens on localhost:9000 , consult your search engine of choice for basic install instructions. Once this is set up, the above guide should be everything you need to then use X. We recommend using the above nginx configuration as a starting point if you're unsure. In this basic form, it instructs nginx to rewrite any requests for files that do not exist to your public/index.php which then processes any requests by checking your registered routes . Once done, you can check your web application responds as expected. Use your favorite web browser or command-line tool: $ curl http://localhost/ Hello w\u00f6rld! Caddy \u00b6 Caddy is an extensible, cross-platform, open-source web server written in Go. Many projects use Caddy because of its ease of use in configuration, and its headlining feature, Automatic HTTPS, which provisions TLS certificates for your sites and keeps them renewed. X supports Caddy out of the box. If you've used Caddy before to run any PHP application, using Caddy with X is as simple as dropping the project files in the right directory. Accordingly, this guide assumes you want to process a number of dynamic routes through X and optionally include some public assets (such as style sheets and images). \u2139\ufe0f PHP-FPM or reverse proxy? This section assumes you want to use Caddy with PHP-FPM which is a very common, traditional web stack. If you want to get the most out of X, you may also want to look into using the built-in web server with Caddy's reverse proxy . Assuming you've followed the quickstart guide , all you need to do is to point Caddy's root directive to the public/ directory of your project. On top of this, you'll need to instruct Caddy to process any dynamic requests through X. This can be achieved by using a Caddyfile configuration with the following contents: example.com { root * /var/www/html/public encode gzip php_fastcgi localhost:9000 file_server } Caddy's php_fastcgi directive is ready out-of-the-box to serve modern PHP sites. This will also automatically provision a TLS certificate for your domain (e.g. example.com \u2013 replace it with your own domain) on startup, assuming your DNS is properly configured to point to your server, and your server is publicly accessible on ports 80 and 443. \u2139\ufe0f New to Caddy? A complete Caddyfile configuration is out of scope for this guide, so we assume you already have Caddy and PHP with PHP-FPM up and running. In this example, we're assuming PHP-FPM is already up and running and listens on localhost:9000 , consult your search engine of choice for basic install instructions. Once this is set up, the above guide should be everything you need to then use X. We recommend using the above Caddy configuration as a starting point if you're unsure. Once done, you can check your web application responds as expected. Use your favorite web browser or command-line tool: $ curl https://example.com/ Hello w\u00f6rld! Apache \u00b6 The Apache HTTP server (httpd) is one of the most popular web servers. In particular, it is a very common choice for hosts that run multiple web applications (such as shared hosting providers) due to its ease of use and support for dynamic configuration through .htaccess files. X supports Apache out of the box. If you've used Apache before to run any PHP application, using Apache with X is as simple as dropping the project files in the right directory. Accordingly, this guide assumes you want to process a number of dynamic routes through X and optionally include some public assets (such as style sheets and images). Assuming you've followed the quickstart guide , all you need to do is to point the Apache's DocumentRoot (\"docroot\") to the public/ directory of your project. On top of this, you'll need to instruct Apache to rewrite dynamic requests so they will be processed by X. Inside your public/ directory, create an .htaccess file (note the leading . which makes this a hidden file) with the following contents: public/.htaccess RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule .* index.php # Optional: handle `.htaccess` with Framework X instead of `403 Forbidden` ErrorDocument 403 /%{REQUEST_URI}/../index.php # This adds support for authorization header SetEnvIf Authorization .+ HTTP_AUTHORIZATION=$0 \u2139\ufe0f New to mod_rewrite? We recommend using the above .htaccess file as a starting point if you're unsure. In this basic form, it instructs Apache to rewrite any requests for files that do not exist to your public/index.php which then processes any requests by checking your registered routes . This requires the mod_rewrite Apache module, which should be enabled by default on most platforms. On Ubuntu- or Debian-based systems, you may enable it like this: $ sudo a2enmod rewrite Once done, your project directory should now look like this: acme/ \u251c\u2500\u2500 public/ \u2502 \u251c\u2500\u2500 .htaccess \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock If you're not already running an Apache server, you can run your X project with Apache in a temporary Docker container like this: $ docker run -it --rm -p 80 :80 -v \" $PWD \" :/srv php:8.4-apache sh -c \"rmdir /var/www/html;ln -s /srv/public /var/www/html;ln -s /etc/apache2/mods-available/rewrite.load /etc/apache2/mods-enabled; apache2-foreground\" In order to check your web application responds as expected, you can use your favorite web browser or command-line tool: $ curl http://localhost/ Hello w\u00f6rld! Built-in web server \u00b6 But there's more! Framework X ships its own efficient web server implementation written in pure PHP. This uses an event-driven architecture to allow you to get the most out of Framework X. With the built-in web server, we provide a non-blocking implementation that can handle thousands of incoming connections and provide a much better user experience in high-load scenarios. With no changes required, you can run the built-in web server with the exact same code base on the command line: $ php public/index.php Let's take a look and see this works just like before: $ curl http://localhost:8080/ Hello w\u00f6rld! You may be wondering how fast a pure PHP web server implementation could possibly be. In fact, in benchmarks this setup outperforms any traditional PHP stack by orders of magnitude. The answer: Lightning fast! Listen address \u00b6 By default, X will listen on http://127.0.0.1:8080 , i.e. you can connect to it on the local port 8080 , but you can not connect to it from outside the system it's running on. This is a common approach when running this behind a reverse proxy such as nginx, HAproxy, etc. for TLS termination as discussed in the next chapter. If you want to change the listen address, you can pass an IP and port combination through the X_LISTEN environment variable like this: $ X_LISTEN = 127 .0.0.1:8081 php public/index.php While not usually recommended (see nginx reverse proxy ), you can also expose this to the public by using the special 0.0.0.0 IPv4 address or [::] IPv6 address like this: $ X_LISTEN = 0 .0.0.0:8080 php public/index.php \u2139\ufe0f Saving environment variables For temporary testing purposes, you may explicitly export your environment variables on the command like above. As a more permanent solution, you may want to save your environment variables in your systemd configuration , Docker settings , load your variables from a dotenv file ( .env ) using a library such as vlucas/phpdotenv , or use an explicit Container configuration . Memory limit \u00b6 X is carefully designed to minimize memory usage. Depending on your application workload, it may need anywhere from a few kilobytes to a couple of megabytes per request. Once the request is completely handled, used memory will be freed again. Under load spikes, memory may temporarily increase to handle concurrent requests. PHP can handle this load just fine, but many default setups use a rather low memory limit that is more suited for single requests only. Fatal error: Allowed memory size of 134217728 bytes exhausted [\u2026] When using the built-in web server, we highly recommend increasing the memory limit to match your concurrency workload. On Ubuntu- or Debian-based systems, you may change your PHP configuration like this: $ sudoedit /etc/php/8.4/cli/php.ini /etc/php/8.4/cli/php.ini - memory_limit = 128M + memory_limit = -1 FD limits \u00b6 By default, many systems limit the number of file descriptors (FDs) that a single process can have open at once to 1024, and following the Unix philosophy that \"everything is a file\", this also includes network connections. This limit is usually more than enough for most simple use cases, but if you're running a high-concurrency server, you may want to handle more connections simultaneously. No problem \u2013 Framework X has you covered. The ulimit command (or its equivalent in your system's service management tool, like systemd or Docker flags) allows you to set soft and hard limits for the maximum number of open files. Increasing these limits will enable your application to support more concurrent connections: ulimit -n 100000 Additionally, the default event loop implementation in Framework X uses the select() system call, which is also limited to 1024 file descriptors on most systems ( PHP_FD_SETSIZE constant). If you want to use a higher limit, you need to install one of the supported event loop extensions from PECL: ext-ev (recommended) ext-event ext-uv (beta) Besides your ulimit setting, no further configuration is required \u2013 these extensions will automatically be loaded when available. So, whether your application needs to handle hundreds or even millions of connections ( C10k problem ), Framework X has you covered. \u2705 Avoiding misconfigurations Make sure to adjust the ulimit setting according to your specific needs. If you create an outgoing connection for each request (think building a proxy server or using isolated database connections), you may temporarily require two FDs per request. On the other hand, simple applications may get pretty far with just the defaults. As soon as a file or connection is closed, its FD will become available again for future use. Accordingly, many lower-concurrency applications may never hit the limit. If you do hit the limit, any operation that opens new files or connections may fail with an error message like this: Connection to tcp://127.0.0.1:3309 failed: Too many open files (EMFILE) If you increase the ulimit setting, but fail to install one of the supported event loop extensions, your server log may be flooded with the following warning because the event loop would fail repeatedly: stream_select(): You MUST recompile PHP with a larger value of FD_SETSIZE. It is set to 1024, but you have descriptors numbered at least as high as 2048. --enable-fd-setsize=2048 is recommended, but you may want to set it to equal the maximum number of open files supported by your system, in order to avoid seeing this error again at a later date. If your system is seeing 100% CPU usage for no apparent reasons, this may be the reason why. Follow the instructions above or follow the best practices for Docker below. Systemd \u00b6 So far, we're manually executing the application server on the command line and everything works fine for testing purposes. Once we're going to push this to production, we should use service monitoring to make sure the server will automatically restart after system reboot or failure. If we're using an Ubuntu- or Debian-based system, we can use the below instructions to configure systemd to manage our server process with just a few lines of configuration, which makes it super easy to run X in production. \u2139\ufe0f Why systemd? There's a large variety of different tools and options to use for service monitoring, depending on your particular needs. Among these is systemd , which is very wide-spread on Linux-based systems and in fact comes preinstalled with many of the large distributions. But we love choice. If you prefer different tools, you can adjust the following instructions to suit your needs. First, start by creating a systemd unit file for our application. We can simply drop the following configuration template into the systemd configuration directory like this: $ sudoedit /etc/systemd/system/acme.service /etc/systemd/system/acme.service [Unit] Description=ACME server [Service] ExecStart=/usr/bin/php /home/alice/projects/acme/public/index.php User=alice LimitNOFILE=100000 [Install] WantedBy=multi-user.target In this example, we're assuming the system user alice has followed the quickstart example and has successfully installed everything in the /home/alice/projects/acme directory. Make sure to adjust the system user and paths to your application directory and PHP binary to suit your needs. Once the new systemd unit file has been put in place, we need to activate the service unit once like this: $ sudo systemctl enable acme.service Finally, we need to instruct systemd to start our new unit: $ sudo systemctl start acme.service And that's it already! Systemd now monitors our application server and will automatically start, stop and restart the server application when needed. You can check the status at any time like this: $ sudo systemctl status acme.service \u25cf acme.service - ACME server Loaded: loaded ( /etc/systemd/system/acme.service ; enabled ; vendor preset: enabled ) Active: active ( running ) [ \u2026 ] On top of this, you need to restart your service manually when the source code has been modified. In this case, simply execute the following command: $ sudo systemctl restart acme.service This should be enough to get you started with systemd. If you want to learn more about systemd, check out the official documentation . nginx reverse proxy \u00b6 If you're using the built-in web server, X will listen on http://127.0.0.1:8080 by default . Instead of using the X_LISTEN environment to change to a publicly accessible listen address, it's usually recommended to use a reverse proxy instead for production deployments. By using nginx as a reverse proxy, we can leverage a high performance web server to handle static assets (such as style sheets and images) and proxy any requests to dynamic routes through X. On top of this, we can configure nginx to log requests, handle rate limits, and to provide HTTPS support (TLS/SSL termination). Assuming you've followed the quickstart guide , all you need to do is to point the nginx' root (\"docroot\") to the public/ directory of your project. On top of this, you'll need to instruct nginx to process any dynamic requests through X. This can be achieved by using an nginx configuration with the following contents: nginx.conf (reverse proxy with static files) nginx.conf (minimal reverse proxy) server { # Serve static files from `public/`, proxy dynamic requests to Framework X location / { location ~* \\.php$ { try_files /dev/null @x; } root /home/alice/projects/acme/public; try_files $uri @x; } location @x { proxy_pass http://localhost:8080; proxy_set_header Host $host; proxy_set_header Connection \"\"; } # Optional: handle Apache config with Framework X if it exists in `public/` location ~ \\.htaccess$ { try_files /dev/null @x; } } server { # Proxy all requests to Framework X location / { proxy_pass http://localhost:8080; proxy_set_header Host $host; proxy_set_header Connection \"\"; } } \u2139\ufe0f New to nginx? A complete nginx configuration is out of scope for this guide, so we assume you already have nginx up and running. Unlike using nginx with PHP-FPM , this example does not require a PHP-FPM setup. We recommend using the above nginx configuration as a starting point if you're unsure. In this basic form, it instructs nginx to rewrite any requests for files that do not exist to your public/index.php which then processes any requests by checking your registered routes . Once done, you can check your web application responds as expected. Use your favorite web browser or command-line tool: $ curl http://localhost/ Hello w\u00f6rld! Caddy reverse proxy \u00b6 If you're using the built-in web server, X will listen on http://127.0.0.1:8080 by default . Instead of using the X_LISTEN environment to change to a publicly accessible listen address, it's usually recommended to use a reverse proxy instead for production deployments. By using Caddy as a reverse proxy, we can leverage a high performance web server to handle static assets (such as style sheets and images) and proxy any requests to dynamic routes through X. On top of this, we can configure Caddy to log requests, handle rate limits, and to provide HTTPS support (TLS termination). Assuming you've followed the quickstart guide , all you need to do is to point the Caddy's root directive to the public/ directory of your project. On top of this, you'll need to instruct Caddy to process any dynamic requests through X. This can be achieved by using a Caddyfile configuration with the following contents: example.com { root * /var/www/html/public; @static { file {path} {path}/ not path *.php } handle @static { rewrite * {http.matchers.file.relative} file_server } handle { reverse_proxy localhost:8080 } } \u2139\ufe0f New to Caddy? A complete Caddy configuration is out of scope for this guide, so we assume you already have Caddy up and running. Unlike using Caddy with PHP-FPM , this example does not require a PHP-FPM setup. We recommend using the above Caddyfile configuration as a starting point if you're unsure. In this basic form, it instructs Caddy to server any requests for files do exist, and proxy everything else to your X server, which processes any requests by checking your registered routes . Once done, you can check your web application responds as expected. Use your favorite web browser or command-line tool: $ curl https://example.com/ Hello w\u00f6rld! Docker containers \u00b6 X supports running inside Docker containers out of the box. Thanks to the powerful combination of the built-in web server and Docker containers, your web application can be built and shipped anywhere with ease. No matter if you want to have a reproducible development environment or want to scale your production cloud, we've got you covered. Assuming you've followed the quickstart guide , all you need to do is to build and run a Docker image of your project. This can be achieved by using a Dockerfile with the following contents: Dockerfile basics for development Dockerfile for minimal production image Dockerfile # syntax=docker/dockerfile:1 FROM php:8.4-cli WORKDIR /app/ COPY public/ public/ COPY vendor/ vendor/ ENV X_LISTEN = 0 .0.0.0:8080 EXPOSE 8080 ENTRYPOINT [ \"php\" , \"public/index.php\" ] Dockerfile # syntax=docker/dockerfile:1 FROM composer:2 AS build WORKDIR /app/ COPY composer.json composer.lock ./ RUN composer install --no-dev --ignore-platform-reqs --optimize-autoloader FROM php:8.4-alpine # recommended: install optional extensions ext-ev and ext-sockets RUN apk --no-cache add ${ PHPIZE_DEPS } libev linux-headers \\ && pecl install ev \\ && docker-php-ext-enable ev \\ && docker-php-ext-install sockets \\ && apk del ${ PHPIZE_DEPS } linux-headers \\ && echo \"memory_limit = -1\" >> \" $PHP_INI_DIR /conf.d/acme.ini\" WORKDIR /app/ COPY public/ public/ # COPY src/ src/ COPY --from = build /app/vendor/ vendor/ ENV X_LISTEN = 0 .0.0.0:8080 EXPOSE 8080 USER nobody:nobody ENTRYPOINT [ \"php\" , \"public/index.php\" ] Simply place the Dockerfile in your project directory like this: acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u251c\u2500\u2500 composer.lock \u2514\u2500\u2500 Dockerfile As a next step, you need to build a Docker image for your project from the Dockerfile : $ docker build -t acme . Once the Docker image is built, you can run a Docker container from this image: Temporary container in foreground Detached container in background $ docker run -it --rm -p 8080 :8080 acme $ docker run -d --ulimit nofile = 100000 -p 8080 :8080 acme Once running, you can check your web application responds as expected. Use your favorite web browser or command-line tool: $ curl http://localhost:8080/ Hello w\u00f6rld! This should be enough to get you started with Docker. \u2139\ufe0f Getting fancy with Docker A complete Docker tutorial is out of scope for this guide, but here are some interesting pointers for you: If you want to share your application, you may push your Docker image to your image registry of choice (private or public). This allows you to pull and reuse your application image on any infrastructure. Speaking of scalable infrastructure, you may also use X in serverless environments and autoscale your application with your load, anywhere from zero to hundreds of servers and beyond. Endless options!","title":"Production deployment"},{"location":"best-practices/deployment/#production-deployment","text":"One of the nice properties of X is that it runs anywhere , i.e. it works both behind traditional web server setups as well as in a stand-alone environment. This makes it easy to get started with existing web application stacks, yet it provides even more awesome features with its built-in web server.","title":"Production deployment"},{"location":"best-practices/deployment/#traditional-stacks","text":"No matter what existing PHP stack you're using, X runs anywhere. This means that if you've already used PHP before, X will just work . nginx or Caddy with PHP-FPM Apache with PHP-FPM, mod_fcgid, mod_cgi or mod_php Any other web server using FastCGI to talk to PHP-FPM Linux, Mac and Windows operating systems ( LAMP, MAMP, WAMP ) We've got you covered!","title":"Traditional stacks"},{"location":"best-practices/deployment/#php-development-web-server","text":"For example, if you've followed the quickstart guide , you can run this using PHP's built-in development web server for testing purposes like this: $ php -S 0 .0.0.0:8080 public/index.php In order to check your web application responds as expected, you can use your favorite web browser or command-line tool: $ curl http://localhost:8080/ Hello w\u00f6rld!","title":"PHP development web server"},{"location":"best-practices/deployment/#nginx","text":"nginx is a high performance web server, load balancer and reverse proxy. In particular, its high performance and versatility makes it one of the most popular web servers. It is used everywhere from the smallest projects to the biggest enterprises. X supports nginx out of the box. If you've used nginx before to run any PHP application, using nginx with X is as simple as dropping the project files in the right directory. Accordingly, this guide assumes you want to process a number of dynamic routes through X and optionally include some public assets (such as style sheets and images). \u2139\ufe0f PHP-FPM or reverse proxy? This section assumes you want to use nginx with PHP-FPM which is a very common, traditional web stack. If you want to get the most out of X, you may also want to look into using the built-in web server with an nginx reverse proxy . Assuming you've followed the quickstart guide , all you need to do is to point the nginx' root (\"docroot\") to the public/ directory of your project. On top of this, you'll need to instruct nginx to process any dynamic requests through X. This can be achieved by using an nginx configuration with the following contents: server { root /home/alice/projects/acme/public; index index.php index.html; location / { try_files $uri $uri/ /index.php$is_args$args; } # Optional: handle Apache config with Framework X if it exists in `public/` error_page 403 = /index.php; location ~ \\.htaccess$ { deny all; } location ~ \\.php$ { fastcgi_pass localhost:9000; fastcgi_split_path_info ^(.+\\.php)(/.+)$; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; } } \u2139\ufe0f New to nginx? A complete nginx configuration is out of scope for this guide, so we assume you already have nginx and PHP with PHP-FPM up and running. In this example, we're assuming PHP-FPM is already up and running and listens on localhost:9000 , consult your search engine of choice for basic install instructions. Once this is set up, the above guide should be everything you need to then use X. We recommend using the above nginx configuration as a starting point if you're unsure. In this basic form, it instructs nginx to rewrite any requests for files that do not exist to your public/index.php which then processes any requests by checking your registered routes . Once done, you can check your web application responds as expected. Use your favorite web browser or command-line tool: $ curl http://localhost/ Hello w\u00f6rld!","title":"nginx"},{"location":"best-practices/deployment/#caddy","text":"Caddy is an extensible, cross-platform, open-source web server written in Go. Many projects use Caddy because of its ease of use in configuration, and its headlining feature, Automatic HTTPS, which provisions TLS certificates for your sites and keeps them renewed. X supports Caddy out of the box. If you've used Caddy before to run any PHP application, using Caddy with X is as simple as dropping the project files in the right directory. Accordingly, this guide assumes you want to process a number of dynamic routes through X and optionally include some public assets (such as style sheets and images). \u2139\ufe0f PHP-FPM or reverse proxy? This section assumes you want to use Caddy with PHP-FPM which is a very common, traditional web stack. If you want to get the most out of X, you may also want to look into using the built-in web server with Caddy's reverse proxy . Assuming you've followed the quickstart guide , all you need to do is to point Caddy's root directive to the public/ directory of your project. On top of this, you'll need to instruct Caddy to process any dynamic requests through X. This can be achieved by using a Caddyfile configuration with the following contents: example.com { root * /var/www/html/public encode gzip php_fastcgi localhost:9000 file_server } Caddy's php_fastcgi directive is ready out-of-the-box to serve modern PHP sites. This will also automatically provision a TLS certificate for your domain (e.g. example.com \u2013 replace it with your own domain) on startup, assuming your DNS is properly configured to point to your server, and your server is publicly accessible on ports 80 and 443. \u2139\ufe0f New to Caddy? A complete Caddyfile configuration is out of scope for this guide, so we assume you already have Caddy and PHP with PHP-FPM up and running. In this example, we're assuming PHP-FPM is already up and running and listens on localhost:9000 , consult your search engine of choice for basic install instructions. Once this is set up, the above guide should be everything you need to then use X. We recommend using the above Caddy configuration as a starting point if you're unsure. Once done, you can check your web application responds as expected. Use your favorite web browser or command-line tool: $ curl https://example.com/ Hello w\u00f6rld!","title":"Caddy"},{"location":"best-practices/deployment/#apache","text":"The Apache HTTP server (httpd) is one of the most popular web servers. In particular, it is a very common choice for hosts that run multiple web applications (such as shared hosting providers) due to its ease of use and support for dynamic configuration through .htaccess files. X supports Apache out of the box. If you've used Apache before to run any PHP application, using Apache with X is as simple as dropping the project files in the right directory. Accordingly, this guide assumes you want to process a number of dynamic routes through X and optionally include some public assets (such as style sheets and images). Assuming you've followed the quickstart guide , all you need to do is to point the Apache's DocumentRoot (\"docroot\") to the public/ directory of your project. On top of this, you'll need to instruct Apache to rewrite dynamic requests so they will be processed by X. Inside your public/ directory, create an .htaccess file (note the leading . which makes this a hidden file) with the following contents: public/.htaccess RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule .* index.php # Optional: handle `.htaccess` with Framework X instead of `403 Forbidden` ErrorDocument 403 /%{REQUEST_URI}/../index.php # This adds support for authorization header SetEnvIf Authorization .+ HTTP_AUTHORIZATION=$0 \u2139\ufe0f New to mod_rewrite? We recommend using the above .htaccess file as a starting point if you're unsure. In this basic form, it instructs Apache to rewrite any requests for files that do not exist to your public/index.php which then processes any requests by checking your registered routes . This requires the mod_rewrite Apache module, which should be enabled by default on most platforms. On Ubuntu- or Debian-based systems, you may enable it like this: $ sudo a2enmod rewrite Once done, your project directory should now look like this: acme/ \u251c\u2500\u2500 public/ \u2502 \u251c\u2500\u2500 .htaccess \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock If you're not already running an Apache server, you can run your X project with Apache in a temporary Docker container like this: $ docker run -it --rm -p 80 :80 -v \" $PWD \" :/srv php:8.4-apache sh -c \"rmdir /var/www/html;ln -s /srv/public /var/www/html;ln -s /etc/apache2/mods-available/rewrite.load /etc/apache2/mods-enabled; apache2-foreground\" In order to check your web application responds as expected, you can use your favorite web browser or command-line tool: $ curl http://localhost/ Hello w\u00f6rld!","title":"Apache"},{"location":"best-practices/deployment/#built-in-web-server","text":"But there's more! Framework X ships its own efficient web server implementation written in pure PHP. This uses an event-driven architecture to allow you to get the most out of Framework X. With the built-in web server, we provide a non-blocking implementation that can handle thousands of incoming connections and provide a much better user experience in high-load scenarios. With no changes required, you can run the built-in web server with the exact same code base on the command line: $ php public/index.php Let's take a look and see this works just like before: $ curl http://localhost:8080/ Hello w\u00f6rld! You may be wondering how fast a pure PHP web server implementation could possibly be. In fact, in benchmarks this setup outperforms any traditional PHP stack by orders of magnitude. The answer: Lightning fast!","title":"Built-in web server"},{"location":"best-practices/deployment/#listen-address","text":"By default, X will listen on http://127.0.0.1:8080 , i.e. you can connect to it on the local port 8080 , but you can not connect to it from outside the system it's running on. This is a common approach when running this behind a reverse proxy such as nginx, HAproxy, etc. for TLS termination as discussed in the next chapter. If you want to change the listen address, you can pass an IP and port combination through the X_LISTEN environment variable like this: $ X_LISTEN = 127 .0.0.1:8081 php public/index.php While not usually recommended (see nginx reverse proxy ), you can also expose this to the public by using the special 0.0.0.0 IPv4 address or [::] IPv6 address like this: $ X_LISTEN = 0 .0.0.0:8080 php public/index.php \u2139\ufe0f Saving environment variables For temporary testing purposes, you may explicitly export your environment variables on the command like above. As a more permanent solution, you may want to save your environment variables in your systemd configuration , Docker settings , load your variables from a dotenv file ( .env ) using a library such as vlucas/phpdotenv , or use an explicit Container configuration .","title":"Listen address"},{"location":"best-practices/deployment/#memory-limit","text":"X is carefully designed to minimize memory usage. Depending on your application workload, it may need anywhere from a few kilobytes to a couple of megabytes per request. Once the request is completely handled, used memory will be freed again. Under load spikes, memory may temporarily increase to handle concurrent requests. PHP can handle this load just fine, but many default setups use a rather low memory limit that is more suited for single requests only. Fatal error: Allowed memory size of 134217728 bytes exhausted [\u2026] When using the built-in web server, we highly recommend increasing the memory limit to match your concurrency workload. On Ubuntu- or Debian-based systems, you may change your PHP configuration like this: $ sudoedit /etc/php/8.4/cli/php.ini /etc/php/8.4/cli/php.ini - memory_limit = 128M + memory_limit = -1","title":"Memory limit"},{"location":"best-practices/deployment/#fd-limits","text":"By default, many systems limit the number of file descriptors (FDs) that a single process can have open at once to 1024, and following the Unix philosophy that \"everything is a file\", this also includes network connections. This limit is usually more than enough for most simple use cases, but if you're running a high-concurrency server, you may want to handle more connections simultaneously. No problem \u2013 Framework X has you covered. The ulimit command (or its equivalent in your system's service management tool, like systemd or Docker flags) allows you to set soft and hard limits for the maximum number of open files. Increasing these limits will enable your application to support more concurrent connections: ulimit -n 100000 Additionally, the default event loop implementation in Framework X uses the select() system call, which is also limited to 1024 file descriptors on most systems ( PHP_FD_SETSIZE constant). If you want to use a higher limit, you need to install one of the supported event loop extensions from PECL: ext-ev (recommended) ext-event ext-uv (beta) Besides your ulimit setting, no further configuration is required \u2013 these extensions will automatically be loaded when available. So, whether your application needs to handle hundreds or even millions of connections ( C10k problem ), Framework X has you covered. \u2705 Avoiding misconfigurations Make sure to adjust the ulimit setting according to your specific needs. If you create an outgoing connection for each request (think building a proxy server or using isolated database connections), you may temporarily require two FDs per request. On the other hand, simple applications may get pretty far with just the defaults. As soon as a file or connection is closed, its FD will become available again for future use. Accordingly, many lower-concurrency applications may never hit the limit. If you do hit the limit, any operation that opens new files or connections may fail with an error message like this: Connection to tcp://127.0.0.1:3309 failed: Too many open files (EMFILE) If you increase the ulimit setting, but fail to install one of the supported event loop extensions, your server log may be flooded with the following warning because the event loop would fail repeatedly: stream_select(): You MUST recompile PHP with a larger value of FD_SETSIZE. It is set to 1024, but you have descriptors numbered at least as high as 2048. --enable-fd-setsize=2048 is recommended, but you may want to set it to equal the maximum number of open files supported by your system, in order to avoid seeing this error again at a later date. If your system is seeing 100% CPU usage for no apparent reasons, this may be the reason why. Follow the instructions above or follow the best practices for Docker below.","title":"FD limits"},{"location":"best-practices/deployment/#systemd","text":"So far, we're manually executing the application server on the command line and everything works fine for testing purposes. Once we're going to push this to production, we should use service monitoring to make sure the server will automatically restart after system reboot or failure. If we're using an Ubuntu- or Debian-based system, we can use the below instructions to configure systemd to manage our server process with just a few lines of configuration, which makes it super easy to run X in production. \u2139\ufe0f Why systemd? There's a large variety of different tools and options to use for service monitoring, depending on your particular needs. Among these is systemd , which is very wide-spread on Linux-based systems and in fact comes preinstalled with many of the large distributions. But we love choice. If you prefer different tools, you can adjust the following instructions to suit your needs. First, start by creating a systemd unit file for our application. We can simply drop the following configuration template into the systemd configuration directory like this: $ sudoedit /etc/systemd/system/acme.service /etc/systemd/system/acme.service [Unit] Description=ACME server [Service] ExecStart=/usr/bin/php /home/alice/projects/acme/public/index.php User=alice LimitNOFILE=100000 [Install] WantedBy=multi-user.target In this example, we're assuming the system user alice has followed the quickstart example and has successfully installed everything in the /home/alice/projects/acme directory. Make sure to adjust the system user and paths to your application directory and PHP binary to suit your needs. Once the new systemd unit file has been put in place, we need to activate the service unit once like this: $ sudo systemctl enable acme.service Finally, we need to instruct systemd to start our new unit: $ sudo systemctl start acme.service And that's it already! Systemd now monitors our application server and will automatically start, stop and restart the server application when needed. You can check the status at any time like this: $ sudo systemctl status acme.service \u25cf acme.service - ACME server Loaded: loaded ( /etc/systemd/system/acme.service ; enabled ; vendor preset: enabled ) Active: active ( running ) [ \u2026 ] On top of this, you need to restart your service manually when the source code has been modified. In this case, simply execute the following command: $ sudo systemctl restart acme.service This should be enough to get you started with systemd. If you want to learn more about systemd, check out the official documentation .","title":"Systemd"},{"location":"best-practices/deployment/#nginx-reverse-proxy","text":"If you're using the built-in web server, X will listen on http://127.0.0.1:8080 by default . Instead of using the X_LISTEN environment to change to a publicly accessible listen address, it's usually recommended to use a reverse proxy instead for production deployments. By using nginx as a reverse proxy, we can leverage a high performance web server to handle static assets (such as style sheets and images) and proxy any requests to dynamic routes through X. On top of this, we can configure nginx to log requests, handle rate limits, and to provide HTTPS support (TLS/SSL termination). Assuming you've followed the quickstart guide , all you need to do is to point the nginx' root (\"docroot\") to the public/ directory of your project. On top of this, you'll need to instruct nginx to process any dynamic requests through X. This can be achieved by using an nginx configuration with the following contents: nginx.conf (reverse proxy with static files) nginx.conf (minimal reverse proxy) server { # Serve static files from `public/`, proxy dynamic requests to Framework X location / { location ~* \\.php$ { try_files /dev/null @x; } root /home/alice/projects/acme/public; try_files $uri @x; } location @x { proxy_pass http://localhost:8080; proxy_set_header Host $host; proxy_set_header Connection \"\"; } # Optional: handle Apache config with Framework X if it exists in `public/` location ~ \\.htaccess$ { try_files /dev/null @x; } } server { # Proxy all requests to Framework X location / { proxy_pass http://localhost:8080; proxy_set_header Host $host; proxy_set_header Connection \"\"; } } \u2139\ufe0f New to nginx? A complete nginx configuration is out of scope for this guide, so we assume you already have nginx up and running. Unlike using nginx with PHP-FPM , this example does not require a PHP-FPM setup. We recommend using the above nginx configuration as a starting point if you're unsure. In this basic form, it instructs nginx to rewrite any requests for files that do not exist to your public/index.php which then processes any requests by checking your registered routes . Once done, you can check your web application responds as expected. Use your favorite web browser or command-line tool: $ curl http://localhost/ Hello w\u00f6rld!","title":"nginx reverse proxy"},{"location":"best-practices/deployment/#caddy-reverse-proxy","text":"If you're using the built-in web server, X will listen on http://127.0.0.1:8080 by default . Instead of using the X_LISTEN environment to change to a publicly accessible listen address, it's usually recommended to use a reverse proxy instead for production deployments. By using Caddy as a reverse proxy, we can leverage a high performance web server to handle static assets (such as style sheets and images) and proxy any requests to dynamic routes through X. On top of this, we can configure Caddy to log requests, handle rate limits, and to provide HTTPS support (TLS termination). Assuming you've followed the quickstart guide , all you need to do is to point the Caddy's root directive to the public/ directory of your project. On top of this, you'll need to instruct Caddy to process any dynamic requests through X. This can be achieved by using a Caddyfile configuration with the following contents: example.com { root * /var/www/html/public; @static { file {path} {path}/ not path *.php } handle @static { rewrite * {http.matchers.file.relative} file_server } handle { reverse_proxy localhost:8080 } } \u2139\ufe0f New to Caddy? A complete Caddy configuration is out of scope for this guide, so we assume you already have Caddy up and running. Unlike using Caddy with PHP-FPM , this example does not require a PHP-FPM setup. We recommend using the above Caddyfile configuration as a starting point if you're unsure. In this basic form, it instructs Caddy to server any requests for files do exist, and proxy everything else to your X server, which processes any requests by checking your registered routes . Once done, you can check your web application responds as expected. Use your favorite web browser or command-line tool: $ curl https://example.com/ Hello w\u00f6rld!","title":"Caddy reverse proxy"},{"location":"best-practices/deployment/#docker-containers","text":"X supports running inside Docker containers out of the box. Thanks to the powerful combination of the built-in web server and Docker containers, your web application can be built and shipped anywhere with ease. No matter if you want to have a reproducible development environment or want to scale your production cloud, we've got you covered. Assuming you've followed the quickstart guide , all you need to do is to build and run a Docker image of your project. This can be achieved by using a Dockerfile with the following contents: Dockerfile basics for development Dockerfile for minimal production image Dockerfile # syntax=docker/dockerfile:1 FROM php:8.4-cli WORKDIR /app/ COPY public/ public/ COPY vendor/ vendor/ ENV X_LISTEN = 0 .0.0.0:8080 EXPOSE 8080 ENTRYPOINT [ \"php\" , \"public/index.php\" ] Dockerfile # syntax=docker/dockerfile:1 FROM composer:2 AS build WORKDIR /app/ COPY composer.json composer.lock ./ RUN composer install --no-dev --ignore-platform-reqs --optimize-autoloader FROM php:8.4-alpine # recommended: install optional extensions ext-ev and ext-sockets RUN apk --no-cache add ${ PHPIZE_DEPS } libev linux-headers \\ && pecl install ev \\ && docker-php-ext-enable ev \\ && docker-php-ext-install sockets \\ && apk del ${ PHPIZE_DEPS } linux-headers \\ && echo \"memory_limit = -1\" >> \" $PHP_INI_DIR /conf.d/acme.ini\" WORKDIR /app/ COPY public/ public/ # COPY src/ src/ COPY --from = build /app/vendor/ vendor/ ENV X_LISTEN = 0 .0.0.0:8080 EXPOSE 8080 USER nobody:nobody ENTRYPOINT [ \"php\" , \"public/index.php\" ] Simply place the Dockerfile in your project directory like this: acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u251c\u2500\u2500 composer.lock \u2514\u2500\u2500 Dockerfile As a next step, you need to build a Docker image for your project from the Dockerfile : $ docker build -t acme . Once the Docker image is built, you can run a Docker container from this image: Temporary container in foreground Detached container in background $ docker run -it --rm -p 8080 :8080 acme $ docker run -d --ulimit nofile = 100000 -p 8080 :8080 acme Once running, you can check your web application responds as expected. Use your favorite web browser or command-line tool: $ curl http://localhost:8080/ Hello w\u00f6rld! This should be enough to get you started with Docker. \u2139\ufe0f Getting fancy with Docker A complete Docker tutorial is out of scope for this guide, but here are some interesting pointers for you: If you want to share your application, you may push your Docker image to your image registry of choice (private or public). This allows you to pull and reuse your application image on any infrastructure. Speaking of scalable infrastructure, you may also use X in serverless environments and autoscale your application with your load, anywhere from zero to hundreds of servers and beyond. Endless options!","title":"Docker containers"},{"location":"best-practices/testing/","text":"Testing \u00b6 \u2139\ufe0f New to testing your web application? While we don't want to force you to test your app, we want to emphasize the importance of automated test suites and try hard to make testing your web application as easy as possible. Tests allow you to verify correct behavior of your implementation, so that you match expected behavior with the actual implementation. And perhaps more importantly, by automating this process you can be sure future changes do not introduce any regressions and suddenly break something else. Develop your application with ease and certainty. We \u2764\ufe0f TDD ! PHPUnit basics \u00b6 Once your app is structured into dedicated controller classes as per the previous chapter, we can test each controller class in isolation. This way, testing becomes pretty straight forward. Let's start simple and write some unit tests for our simple HelloController class: src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); } } As a first step, we need to install PHPUnit with Composer by running this command in the project directory: $ composer require --dev phpunit/phpunit \u2139\ufe0f New to PHPUnit? If you haven't heard about PHPUnit before, PHPUnit is the testing framework for PHP projects. After installing it as a development dependency, we can take advantage of its structure to write tests for our own application. Next, we can start by creating our first unit test: tests/HelloControllerTest.php <?php namespace Acme\\Tests\\Todo ; use Acme\\Todo\\HelloController ; use PHPUnit\\Framework\\TestCase ; use Psr\\Http\\Message\\ResponseInterface ; use React\\Http\\Message\\ServerRequest ; class HelloControllerTest extends TestCase { public function testControllerReturnsValidResponse () { $request = new ServerRequest ( 'GET' , 'http://example.com/' ); $controller = new HelloController (); $response = $controller ( $request ); $this -> assertInstanceOf ( ResponseInterface :: class , $response ); $this -> assertEquals ( 200 , $response -> getStatusCode ()); $this -> assertEquals ( \"Hello w\u00f6rld! \\n \" , ( string ) $response -> getBody ()); } } We're intentionally starting simple. By starting with a controller class following a somewhat trivial implementation, we can focus on just getting the test suite up and running first. All following tests will also follow a somewhat similar structure, so we can always use this as a simple building block: create an HTTP request object pass it into our controller function and then run assertions on the expected HTTP response object. Once you've created your first unit tests, it's time to run PHPUnit by executing this command in the project directory: $ vendor/bin/phpunit tests PHPUnit 9.5.4 by Sebastian Bergmann and contributors. . 1 / 1 (100%) Time: 00:00.006, Memory: 4.00 MB OK (1 test, 1 assertion) Testing with specific requests \u00b6 Once the basic test setup works, let's continue with testing a controller that shows different behavior depending on what HTTP request comes in. For this example, we're using request attributes , but the same logic applies to testing different URLs, HTTP request headers, etc.: src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { return Response :: plaintext ( \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); } } Again, we create a new test class matching the controller class: tests/UserControllerTest.php <?php namespace Acme\\Tests\\Todo ; use Acme\\Todo\\UserController ; use PHPUnit\\Framework\\TestCase ; use Psr\\Http\\Message\\ResponseInterface ; use React\\Http\\Message\\ServerRequest ; class UserControllerTest extends TestCase { public function testControllerReturnsValidResponse () { $request = new ServerRequest ( 'GET' , 'http://example.com/users/Alice' ); $request = $request -> withAttribute ( 'name' , 'Alice' ); $controller = new UserController (); $response = $controller ( $request ); $this -> assertInstanceOf ( ResponseInterface :: class , $response ); $this -> assertEquals ( 200 , $response -> getStatusCode ()); $this -> assertEquals ( \"Hello Alice! \\n \" , ( string ) $response -> getBody ()); } } This follows the exact same logic like the previous example, except this time we're setting up a specific HTTP request and asserting the HTTP response contains the correct name. Again, we can run PHPUnit in the project directory to see this works as expected: $ vendor/bin/phpunit tests PHPUnit 9.5.4 by Sebastian Bergmann and contributors. .. 2 / 2 (100%) Time: 00:00.003, Memory: 4.00 MB OK (2 tests, 2 assertions) Further reading \u00b6 If you've made it this far, you should have a basic understanding about how testing can help you develop your application with ease and certainty . We believe mastering TTD is well worth it, but perhaps this is somewhat out of scope for this documentation. If you're curious, we recommend looking into the following topics: TDD Higher-level functional tests Test automation CI / CD","title":"Testing"},{"location":"best-practices/testing/#testing","text":"\u2139\ufe0f New to testing your web application? While we don't want to force you to test your app, we want to emphasize the importance of automated test suites and try hard to make testing your web application as easy as possible. Tests allow you to verify correct behavior of your implementation, so that you match expected behavior with the actual implementation. And perhaps more importantly, by automating this process you can be sure future changes do not introduce any regressions and suddenly break something else. Develop your application with ease and certainty. We \u2764\ufe0f TDD !","title":"Testing"},{"location":"best-practices/testing/#phpunit-basics","text":"Once your app is structured into dedicated controller classes as per the previous chapter, we can test each controller class in isolation. This way, testing becomes pretty straight forward. Let's start simple and write some unit tests for our simple HelloController class: src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); } } As a first step, we need to install PHPUnit with Composer by running this command in the project directory: $ composer require --dev phpunit/phpunit \u2139\ufe0f New to PHPUnit? If you haven't heard about PHPUnit before, PHPUnit is the testing framework for PHP projects. After installing it as a development dependency, we can take advantage of its structure to write tests for our own application. Next, we can start by creating our first unit test: tests/HelloControllerTest.php <?php namespace Acme\\Tests\\Todo ; use Acme\\Todo\\HelloController ; use PHPUnit\\Framework\\TestCase ; use Psr\\Http\\Message\\ResponseInterface ; use React\\Http\\Message\\ServerRequest ; class HelloControllerTest extends TestCase { public function testControllerReturnsValidResponse () { $request = new ServerRequest ( 'GET' , 'http://example.com/' ); $controller = new HelloController (); $response = $controller ( $request ); $this -> assertInstanceOf ( ResponseInterface :: class , $response ); $this -> assertEquals ( 200 , $response -> getStatusCode ()); $this -> assertEquals ( \"Hello w\u00f6rld! \\n \" , ( string ) $response -> getBody ()); } } We're intentionally starting simple. By starting with a controller class following a somewhat trivial implementation, we can focus on just getting the test suite up and running first. All following tests will also follow a somewhat similar structure, so we can always use this as a simple building block: create an HTTP request object pass it into our controller function and then run assertions on the expected HTTP response object. Once you've created your first unit tests, it's time to run PHPUnit by executing this command in the project directory: $ vendor/bin/phpunit tests PHPUnit 9.5.4 by Sebastian Bergmann and contributors. . 1 / 1 (100%) Time: 00:00.006, Memory: 4.00 MB OK (1 test, 1 assertion)","title":"PHPUnit basics"},{"location":"best-practices/testing/#testing-with-specific-requests","text":"Once the basic test setup works, let's continue with testing a controller that shows different behavior depending on what HTTP request comes in. For this example, we're using request attributes , but the same logic applies to testing different URLs, HTTP request headers, etc.: src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { return Response :: plaintext ( \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); } } Again, we create a new test class matching the controller class: tests/UserControllerTest.php <?php namespace Acme\\Tests\\Todo ; use Acme\\Todo\\UserController ; use PHPUnit\\Framework\\TestCase ; use Psr\\Http\\Message\\ResponseInterface ; use React\\Http\\Message\\ServerRequest ; class UserControllerTest extends TestCase { public function testControllerReturnsValidResponse () { $request = new ServerRequest ( 'GET' , 'http://example.com/users/Alice' ); $request = $request -> withAttribute ( 'name' , 'Alice' ); $controller = new UserController (); $response = $controller ( $request ); $this -> assertInstanceOf ( ResponseInterface :: class , $response ); $this -> assertEquals ( 200 , $response -> getStatusCode ()); $this -> assertEquals ( \"Hello Alice! \\n \" , ( string ) $response -> getBody ()); } } This follows the exact same logic like the previous example, except this time we're setting up a specific HTTP request and asserting the HTTP response contains the correct name. Again, we can run PHPUnit in the project directory to see this works as expected: $ vendor/bin/phpunit tests PHPUnit 9.5.4 by Sebastian Bergmann and contributors. .. 2 / 2 (100%) Time: 00:00.003, Memory: 4.00 MB OK (2 tests, 2 assertions)","title":"Testing with specific requests"},{"location":"best-practices/testing/#further-reading","text":"If you've made it this far, you should have a basic understanding about how testing can help you develop your application with ease and certainty . We believe mastering TTD is well worth it, but perhaps this is somewhat out of scope for this documentation. If you're curious, we recommend looking into the following topics: TDD Higher-level functional tests Test automation CI / CD","title":"Further reading"},{"location":"getting-started/community/","text":"Community \u00b6 Framework X is so much more than yet another framework , it is the way to introduce asynchronous programming to the broader PHP community. We believe it's essential to involve the whole community in all our processes and provide you with the opportunity to bring up your awesome ideas. Support \u00b6 We are where the open-source community is! We use GitHub discussions and GitHub issues as a great way to keep track of discussions and follow the project progress and upcoming enhancements. See also our community section for more support options, including commercial ones. You may also reach out to us by mentioning @x_framework on Twitter . We would love to hear your feedback! \u2764\ufe0f Want to help out? \u00b6 We actively invite contributors to this project! Follow @x_framework on Twitter Engage in our GitHub discussions Help by giving feedback or triaging GitHub issues Consider becoming a sponsor on GitHub Contribute to our GitHub repository with a code or documentation PR. Happy hacking! If you've tried out X, no matter how small your experiment, make sure to share your results with the world! We would love to hear what you think about X in a tweet mentioning @x_framework . \u2764\ufe0f Open source \u00b6 Framework X is released as open-source under the permissive MIT license. This means it is free as in free speech and as in free beer. We believe in open source and made a conscious decision to take this path. Being open-source means we can foster a community to focus on building the best possible framework together. Framework X builds on top of existing open-source projects and we want to give back to this community of awesome engineers and developers. Being open to outside contributions means we can guarantee interoperability with a vivid ecosystem and ensure the longevity of the project.","title":"Community"},{"location":"getting-started/community/#community","text":"Framework X is so much more than yet another framework , it is the way to introduce asynchronous programming to the broader PHP community. We believe it's essential to involve the whole community in all our processes and provide you with the opportunity to bring up your awesome ideas.","title":"Community"},{"location":"getting-started/community/#support","text":"We are where the open-source community is! We use GitHub discussions and GitHub issues as a great way to keep track of discussions and follow the project progress and upcoming enhancements. See also our community section for more support options, including commercial ones. You may also reach out to us by mentioning @x_framework on Twitter . We would love to hear your feedback! \u2764\ufe0f","title":"Support"},{"location":"getting-started/community/#want-to-help-out","text":"We actively invite contributors to this project! Follow @x_framework on Twitter Engage in our GitHub discussions Help by giving feedback or triaging GitHub issues Consider becoming a sponsor on GitHub Contribute to our GitHub repository with a code or documentation PR. Happy hacking! If you've tried out X, no matter how small your experiment, make sure to share your results with the world! We would love to hear what you think about X in a tweet mentioning @x_framework . \u2764\ufe0f","title":"Want to help out?"},{"location":"getting-started/community/#open-source","text":"Framework X is released as open-source under the permissive MIT license. This means it is free as in free speech and as in free beer. We believe in open source and made a conscious decision to take this path. Being open-source means we can foster a community to focus on building the best possible framework together. Framework X builds on top of existing open-source projects and we want to give back to this community of awesome engineers and developers. Being open to outside contributions means we can guarantee interoperability with a vivid ecosystem and ensure the longevity of the project.","title":"Open source"},{"location":"getting-started/philosophy/","text":"Our philosophy \u00b6 What drives us \u00b6 Framework X is so much more than yet another framework . Here's what drives us and how we make decisions for the framework. make easy things easy & hard things possible Making easy things easy is one of our leading mottos. If making the hard thing possible involves making the easy thing hard, we would rather focus on the easy thing. From quick prototyping RAD to production environments in hours Get started in minutes with a RAD prototype! With X, you can get from prototypes to production in hours, not weeks. Batteries included, but swappable X provides everything you need to get started. We use a very composable architecture, so all the parts are swappable in case you need custom integrations. Reuse where applicable, but accept some duplication Code reuse is great! But if applying DRY involves too many abstractions, we would rather accept some duplication. We value simplicity as a core design principle. Long-term support (LTS) and careful upgrade paths We're committed to providing long-term support (LTS) options and providing a smooth upgrade path between versions. We want to be the rock-solid foundation that you can build on top of. Promote best practices, but don't enforce certain style We like DDD , TDD , and more. If you don't, that's fine, we like choice. While we encourage following best practices and try to give recommendations, we don't enforce a certain style. Runs anywhere We support the latest versions but we only require PHP 7.1+ for maximum compatibility to ensure X runs anywhere. From shared hosting to cloud-native! Open and inclusive community Framework X is so much more than the sum of its parts. In particular, see our awesome community . Architecture \u00b6 HTTP request response semantics Framework X is all about handling HTTP requests and sending back HTTP responses . PHP runs everywhere We know, PHP has its quirks. But it also provides a unique opportunity with its huge ecosystem that allows you to run X literally anywhere. shared-nothing execution (optional) We support PHP's default shared-nothing execution model when running with traditional stacks . built-in web server (optional) If you're ready, get even more awesome features with its built-in web server . Async PHP We're standing on the shoulders of giants. Thank you ReactPHP for providing an awesome foundation!","title":"Our philosophy"},{"location":"getting-started/philosophy/#our-philosophy","text":"","title":"Our philosophy"},{"location":"getting-started/philosophy/#what-drives-us","text":"Framework X is so much more than yet another framework . Here's what drives us and how we make decisions for the framework. make easy things easy & hard things possible Making easy things easy is one of our leading mottos. If making the hard thing possible involves making the easy thing hard, we would rather focus on the easy thing. From quick prototyping RAD to production environments in hours Get started in minutes with a RAD prototype! With X, you can get from prototypes to production in hours, not weeks. Batteries included, but swappable X provides everything you need to get started. We use a very composable architecture, so all the parts are swappable in case you need custom integrations. Reuse where applicable, but accept some duplication Code reuse is great! But if applying DRY involves too many abstractions, we would rather accept some duplication. We value simplicity as a core design principle. Long-term support (LTS) and careful upgrade paths We're committed to providing long-term support (LTS) options and providing a smooth upgrade path between versions. We want to be the rock-solid foundation that you can build on top of. Promote best practices, but don't enforce certain style We like DDD , TDD , and more. If you don't, that's fine, we like choice. While we encourage following best practices and try to give recommendations, we don't enforce a certain style. Runs anywhere We support the latest versions but we only require PHP 7.1+ for maximum compatibility to ensure X runs anywhere. From shared hosting to cloud-native! Open and inclusive community Framework X is so much more than the sum of its parts. In particular, see our awesome community .","title":"What drives us"},{"location":"getting-started/philosophy/#architecture","text":"HTTP request response semantics Framework X is all about handling HTTP requests and sending back HTTP responses . PHP runs everywhere We know, PHP has its quirks. But it also provides a unique opportunity with its huge ecosystem that allows you to run X literally anywhere. shared-nothing execution (optional) We support PHP's default shared-nothing execution model when running with traditional stacks . built-in web server (optional) If you're ready, get even more awesome features with its built-in web server . Async PHP We're standing on the shoulders of giants. Thank you ReactPHP for providing an awesome foundation!","title":"Architecture"},{"location":"getting-started/quickstart/","text":"Quickstart in 5 minutes \u00b6 Getting started with X is easy! Here's a quick tutorial to get you up and running in 5 minutes or less. Start your timer and here we go! Code \u00b6 In order to first start using X, let's start with an entirely empty project directory. This shouldn't be too confusing, but here's how you can do so on the command line: $ mkdir ~/projects/acme/ $ cd ~/projects/acme/ Next, we can start by taking a look at a simple example application. You can use this example to get started by creating a new public/ directory with an index.php file inside: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , function () { return React\\Http\\Message\\Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); }); $app -> get ( '/users/{name}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { return React\\Http\\Message\\Response :: plaintext ( \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); }); $app -> run (); On a code level, this is everything you need to get started. For more sophisticated projects, you may want to make sure to structure your controllers , but the above should be just fine for starters. Installation \u00b6 Next, we need to install X and its dependencies to actually run this project. Thanks to Composer , this installation only requires a single command. \u2139\ufe0f New to Composer? If you haven't heard about Composer before, Composer is the package or dependency manager for PHP-based projects. It takes care of installing PHP projects and any libraries your projects depends on. If you haven't used it before, you have to install a recent PHP version and Composer before you can proceed. On Ubuntu- or Debian-based systems, this would be as simple as this: $ sudo apt install php-cli composer In your project directory, simply run the following command: $ composer require clue/framework-x:^0.17 X is carefully designed to be super lightweight, so this should only take a moment or two. Once installed, your project directory should now look like this: acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock Running \u00b6 The next step after installing all dependencies is now to serve this web application. One of the nice properties of this project is that it runs anywhere (provided you have PHP installed of course). For example, you can run the above example using the built-in web server like this: $ php public/index.php \u2139\ufe0f Framework X runs anywhere This example uses the efficient built-in web server written in pure PHP. We also support running behind traditional web server setups like Apache, nginx, Docker, and more. See production deployment for more details. You can now use your favorite web browser or command line tool to check your web application responds as expected: $ curl http://localhost:8080/ Hello w\u00f6rld! And that's it already, you can now stop your timer. If you've made it this far, you should have an understanding of why X is so exciting. As a next step, we would recommend checking out the best practices in order to deploy this to production. Happy hacking!","title":"Quickstart in 5 minutes"},{"location":"getting-started/quickstart/#quickstart-in-5-minutes","text":"Getting started with X is easy! Here's a quick tutorial to get you up and running in 5 minutes or less. Start your timer and here we go!","title":"Quickstart in 5 minutes"},{"location":"getting-started/quickstart/#code","text":"In order to first start using X, let's start with an entirely empty project directory. This shouldn't be too confusing, but here's how you can do so on the command line: $ mkdir ~/projects/acme/ $ cd ~/projects/acme/ Next, we can start by taking a look at a simple example application. You can use this example to get started by creating a new public/ directory with an index.php file inside: public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , function () { return React\\Http\\Message\\Response :: plaintext ( \"Hello w\u00f6rld! \\n \" ); }); $app -> get ( '/users/{name}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { return React\\Http\\Message\\Response :: plaintext ( \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); }); $app -> run (); On a code level, this is everything you need to get started. For more sophisticated projects, you may want to make sure to structure your controllers , but the above should be just fine for starters.","title":"Code"},{"location":"getting-started/quickstart/#installation","text":"Next, we need to install X and its dependencies to actually run this project. Thanks to Composer , this installation only requires a single command. \u2139\ufe0f New to Composer? If you haven't heard about Composer before, Composer is the package or dependency manager for PHP-based projects. It takes care of installing PHP projects and any libraries your projects depends on. If you haven't used it before, you have to install a recent PHP version and Composer before you can proceed. On Ubuntu- or Debian-based systems, this would be as simple as this: $ sudo apt install php-cli composer In your project directory, simply run the following command: $ composer require clue/framework-x:^0.17 X is carefully designed to be super lightweight, so this should only take a moment or two. Once installed, your project directory should now look like this: acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock","title":"Installation"},{"location":"getting-started/quickstart/#running","text":"The next step after installing all dependencies is now to serve this web application. One of the nice properties of this project is that it runs anywhere (provided you have PHP installed of course). For example, you can run the above example using the built-in web server like this: $ php public/index.php \u2139\ufe0f Framework X runs anywhere This example uses the efficient built-in web server written in pure PHP. We also support running behind traditional web server setups like Apache, nginx, Docker, and more. See production deployment for more details. You can now use your favorite web browser or command line tool to check your web application responds as expected: $ curl http://localhost:8080/ Hello w\u00f6rld! And that's it already, you can now stop your timer. If you've made it this far, you should have an understanding of why X is so exciting. As a next step, we would recommend checking out the best practices in order to deploy this to production. Happy hacking!","title":"Running"},{"location":"integrations/authentication/","text":"Authentication \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! HTTP Basic auth easy to implement Implementation as HTTP middleware recommended JWT and OAuth possible Handling credentials application-specific, may take advantage of database See also sessions","title":"\u26a0 Authentication"},{"location":"integrations/authentication/#authentication","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! HTTP Basic auth easy to implement Implementation as HTTP middleware recommended JWT and OAuth possible Handling credentials application-specific, may take advantage of database See also sessions","title":"Authentication"},{"location":"integrations/child-processes/","text":"Parallel processing with child processes \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Avoid blocking by moving blocking implementation to child process Child process I/O for communication Multithreading, but isolated processes See reactphp/child-process for underlying APIs See clue/reactphp-pq for higher-level API to automatically wrap blocking functions in an async child process and turn blocking functions into non-blocking promises","title":"\u26a0 Child processes"},{"location":"integrations/child-processes/#parallel-processing-with-child-processes","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Avoid blocking by moving blocking implementation to child process Child process I/O for communication Multithreading, but isolated processes See reactphp/child-process for underlying APIs See clue/reactphp-pq for higher-level API to automatically wrap blocking functions in an async child process and turn blocking functions into non-blocking promises","title":"Parallel processing with child processes"},{"location":"integrations/database/","text":"Database \u00b6 One of the most commonly used functionality in web APIs is database access. X supports efficient and fast database access by using async database APIs. Quickstart \u00b6 Let's take a look at the most basic async database integration possible with X: Fibers Coroutines Promises public/index.php <?php use function React\\Async\\await ; require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { $result = await ( $db -> query ( 'SELECT COUNT(*) AS count FROM book' )); $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { $result = yield $db -> query ( 'SELECT COUNT(*) AS count FROM book' ); $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { return $db -> query ( 'SELECT COUNT(*) AS count FROM book' ) -> then ( function ( React\\MySQL\\QueryResult $result ) { $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); }); $app -> run () : As you can see, using an async database adapter in X is very similar to using a normal, synchronous database adapter such as PDO. Why async? \u00b6 Because performance. Using async, non-blocking APIs allows much faster response times by doing multiple things at once, instead of having to do one thing after another. This can be seen when we process multiple concurrent operations at once (such as sending queries to multiple databases or concurrent HTTP requests) or when using the built-in web server which can process thousands of requests at the same time. Especially with Fibers, using async database APIs should be no more complicated than their slower, synchronous counterparts. So the real question should be: Why not? Fibers / Coroutines / Promises \u00b6 The database examples showcase the three different ways to consume async APIs. There are different reasons to pick one over the other, here's a quick overview to help you decide. Fibers allow consuming async APIs using a synchronous code flow. The await() function can be used to \"await\" a promise or to \"unwrap\" its resolution value. Fibers are a core ingredient of PHP 8.1+, but the same syntax also works on older PHP versions to some degree if you only have limited concurrency. See also Fibers for more details. Coroutines allow consuming async APIs in a way that resembles a synchronous code flow. The yield keyword function can be used to \"await\" a promise or to \"unwrap\" its resolution value. Internally, this turns the entire function into a Generator which does affect the way return values need to be accessed. See also Coroutines for more details. Promises are a core building block used in all our async APIs. They are especially useful if want to express a concurrent code flow. You can directly use their API for maximum performance or use Fibers or Coroutines as an easier way to work with async APIs. See also Promises for more details. Which style is better? We like choice. Feel free to use whatever style works best for you. Database adapters \u00b6 Using another database? Don't worry. ReactPHP provides support for major database vendors through a number of ready-to-use packages: MySQL Postgres SQLite Redis ClickHouse And more \u2026 Installing a new database adapter is usually as simple as executing a single composer require call. Most implementations are written in pure PHP and do not require any extensions. All adapters provide similar APIs that allow async access to the given database. In this documentation, we focus on MySQL because it is one of the more common database choices for web development, but the same ideas also apply to all other database implementations. \u2139\ufe0f Legacy, blocking database access? For performance reasons, we highly recommend using async database APIs as described above. For legacy integrations, we provide limited support for blocking database calls such as PDO, Doctrine, etc., but as a rule of thumb, going for an async alternative is usually somewhat more efficient. See child processes for more details. DBAL \u00b6 \u26a0\ufe0f Feature preview This is a feature preview, i.e. it might not have made it into the current beta. Give feedback to help us prioritize. We also welcome contributors to help out! There is ongoing effort to provide an async DBAL (DataBase Abstraction Layer) that will allow you to write your logic in such a way that it is not tied to a specific database adapter. Among others, this will make it easier to support multiple database adapters in a single code base, which is particularly useful for reusable components such as middleware classes . You may also use this to configure different database adapters for testing purposes (such as using SQLite for integration tests and using MySQL in production). At the moment, we recommend using one of the above database adapters directly. Looking forward, the idea is to add an abstraction that uses a common API and provides a native integration with these adapters. Accordingly, switching to the new DBAL APIs should only be a matter of a few minutes, not hours. Expect more details later this year. On top of this, there are ideas to build an ORM (Object-Relational Mapping) in the future. More details will follow. Best practices \u00b6 Query parameters \u00b6 We highly recommend using SQL statements with placeholders for query parameters instead of manually building SQL statements by concatenating quoted strings. For most database adapters, this would be faster, provide additional guarantees against possible SQL injection attacks, and also make the SQL statement easier to understand. As a common example, we can accept a request attribute from a route placeholder like this: Fibers Coroutines Promises public/index.php <?php use function React\\Async\\await ; require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book/{isbn}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) use ( $db ) { $isbn = $request -> getAttribute ( 'isbn' ); $result = await ( $db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] )); assert ( $result instanceof React\\MySQL\\QueryResult ); if ( count ( $result -> resultRows ) === 0 ) { return React\\Http\\Message\\Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( React\\Http\\Message\\Response :: STATUS_NOT_FOUND ); } $data = $result -> resultRows [ 0 ][ 'title' ]; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book/{isbn}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) use ( $db ) { $isbn = $request -> getAttribute ( 'isbn' ); $result = yield $db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ); assert ( $result instanceof React\\MySQL\\QueryResult ); if ( count ( $result -> resultRows ) === 0 ) { return React\\Http\\Message\\Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( React\\Http\\Message\\Response :: STATUS_NOT_FOUND ); } $data = $result -> resultRows [ 0 ][ 'title' ]; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book/{isbn}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) use ( $db ) { $isbn = $request -> getAttribute ( 'isbn' ); return $db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ) -> then ( function ( React\\MySQL\\QueryResult $result ) { if ( count ( $result -> resultRows ) === 0 ) { return React\\Http\\Message\\Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( React\\Http\\Message\\Response :: STATUS_NOT_FOUND ); } $data = $result -> resultRows [ 0 ][ 'title' ]; return React\\Http\\Message\\Response :: plaintext ( $data ); }); }); $app -> run (); Recommended class structure \u00b6 The above examples use inline closure definitions to ease getting started, but it's also easy to see how this will get out of hand for more complex business domains when you have more than a couple of routes registered. For real-world applications, we highly recommend structuring your application into individual controller classes . This way, we can break up this logic into multiple smaller files, that are easier to work with, easier to test in isolation, and easier to reason about. As a starting point, we recommend the following class and directory structure: acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 Book.php \u2502 \u251c\u2500\u2500 BookRepository.php \u2502 \u2514\u2500\u2500 BookLookupController.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock \u2139\ufe0f We \u2764\ufe0f Domain-Driven Design We're big fans of DDD (Domain-Driven Design), which basically is a fancy way of saying: The design of your application should be driven by your business domain requirements, not by some arbitrary technical constraints. In this instance, this means we're breaking up the database logic into their logic parts and using a repository pattern to isolate the entity ( Book ) from the database logic ( BookRepository ) and from the request logic ( BookLookupController ). For newcomers, this may sound like a lot of code at first but actually helps reduce clutter down the line. But don't worry, X does not enforce a particular style, so none of this is strictly required. Use your own best judgment, see controller classes for more details. The main entry point registers a route for our controller and uses dependency injection (DI) or a DI container to wire all classes: Constructor dependency injection DI container public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $repository = new Acme\\Todo\\BookRepository ( $db ); $app = new FrameworkX\\App (); $app -> get ( '/book/{isbn}' , new Acme\\Todo\\BookLookupController ( $repository )); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ React\\MySQL\\ConnectionInterface :: class => function () { $credentials = 'alice:secret@localhost/bookstore' ; return ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); } ]); $app = new FrameworkX\\App ( $container ); $app -> get ( '/book/{isbn}' , Acme\\Todo\\BookLookupController :: class ); $app -> run (); The main entity we're dealing with in this example is a plain PHP class which makes it super easy to write and to use in our code: Readonly constructor property (PHP 8.1+) Typed property (PHP 7.4+) Old school property src/Book.php <?php namespace Acme\\Todo ; class Book { public function __construct ( public readonly string $title ) { } } src/Book.php <?php namespace Acme\\Todo ; class Book { /** @readonly **/ public string $title ; public function __construct ( string $title ) { $this -> title = $title ; } } src/Book.php <?php namespace Acme\\Todo ; class Book { /** * @var string * @readonly */ public $title ; public function __construct ( string $title ) { $this -> title = $title ; } } The database logic and request handling is separated into two classes that interface with each other using a simple async API: Fibers Coroutines Promises src/BookRepository.php <?php namespace Acme\\Todo ; use React\\MySQL\\ConnectionInterface ; use React\\MySQL\\QueryResult ; use function React\\Async\\await ; class BookRepository { private $db ; public function __construct ( ConnectionInterface $db ) { $this -> db = $db ; } public function findBook ( string $isbn ) : ? Book { $result = await ( $this -> db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] )); assert ( $result instanceof QueryResult ); if ( count ( $result -> resultRows ) === 0 ) { return null ; } return new Book ( $result -> resultRows [ 0 ][ 'title' ]); } } src/BookLookupController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class BookLookupController { private $repository ; public function __construct ( BookRepository $repository ) { $this -> repository = $repository ; } public function __invoke ( ServerRequestInterface $request ) : ResponseInterface { $isbn = $request -> getAttribute ( 'isbn' ); $book = $this -> repository -> findBook ( $isbn ); if ( $book === null ) { return Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( Response :: STATUS_NOT_FOUND ); } $data = $book -> title ; return Response :: plaintext ( $data ); } } src/BookRepository.php <?php namespace Acme\\Todo ; use React\\MySQL\\ConnectionInterface ; use React\\MySQL\\QueryResult ; use React\\Promise\\PromiseInterface ; class BookRepository { private $db ; public function __construct ( ConnectionInterface $db ) { $this -> db = $db ; } /** @return \\Generator<mixed,PromiseInterface,mixed,?Book> **/ public function findBook ( string $isbn ) : \\Generator { $result = yield $this -> db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ); assert ( $result instanceof QueryResult ); if ( count ( $result -> resultRows ) === 0 ) { return null ; } return new Book ( $result -> resultRows [ 0 ][ 'title' ]); } } src/BookLookupController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; use React\\Promise\\PromiseInterface ; class BookLookupController { private $repository ; public function __construct ( BookRepository $repository ) { $this -> repository = $repository ; } /** @return \\Generator<mixed,PromiseInterface,mixed,ResponseInterface> **/ public function __invoke ( ServerRequestInterface $request ) : \\Generator { $isbn = $request -> getAttribute ( 'isbn' ); $book = yield from $this -> repository -> findBook ( $isbn ); assert ( $book === null || $book instanceof Book ); if ( $book === null ) { return Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( Response :: STATUS_NOT_FOUND ); } $data = $book -> title ; return Response :: plaintext ( $data ); } } src/BookRepository.php <?php namespace Acme\\Todo ; use React\\MySQL\\ConnectionInterface ; use React\\MySQL\\QueryResult ; use React\\Promise\\PromiseInterface ; class BookRepository { private $db ; public function __construct ( ConnectionInterface $db ) { $this -> db = $db ; } /** @return PromiseInterface<?Book> **/ public function findBook ( string $isbn ) : PromiseInterface { return $this -> db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ) -> then ( function ( QueryResult $result ) { if ( count ( $result -> resultRows ) === 0 ) { return null ; } return new Book ( $result -> resultRows [ 0 ][ 'title' ]); }); } } src/BookLookupController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; use React\\Promise\\PromiseInterface ; class BookLookupController { private $repository ; public function __construct ( BookRepository $repository ) { $this -> repository = $repository ; } /** @return PromiseInterface<ResponseInterface> **/ public function __invoke ( ServerRequestInterface $request ) : PromiseInterface { $isbn = $request -> getAttribute ( 'isbn' ); return $this -> repository -> findBook ( $isbn ) -> then ( function ( ? Book $book ) { if ( $book === null ) { return Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( Response :: STATUS_NOT_FOUND ); } $data = $book -> title ; return Response :: plaintext ( $data ); }); } } That's it. We do realize that this looks like a lot of classes, but if you take a look at the code in each class, you'll find that most of this is actually pretty straightforward. Both the logic and the code structure itself are pretty obvious and easy to reason about and improve upon when more features are added. As a next step, we would highly recommend looking into testing . Because we've broken down the logic into very small units, it should be easy to write unit tests that allow us to cover 100% of our logic. See testing for more details. acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 Book.php \u2502 \u251c\u2500\u2500 BookRepository.php \u2502 \u2514\u2500\u2500 BookLookupController.php \u251c\u2500\u2500 tests/ \u2502 \u251c\u2500\u2500 BookTest.php \u2502 \u251c\u2500\u2500 BookRepositoryTest.php \u2502 \u2514\u2500\u2500 BookLookupControllerTest.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock The above structure is what we recommend as a starting point if you're unsure. Once your application starts growing, you will likely want to introduce additional layers to group logic and make cohesion between different classes more obvious. There are multiple ways to go about this, but here are two common structures to get you started: Group by domain Group by functionality acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 Book/ \u2502 \u2502 \u251c\u2500\u2500 Book.php \u2502 \u2502 \u251c\u2500\u2500 BookRepository.php \u2502 \u2502 \u2514\u2500\u2500 BookLookupController.php \u2502 \u2514\u2500\u2500 User/ \u2502 \u251c\u2500\u2500 User.php \u2502 \u251c\u2500\u2500 UserRepository.php \u2502 \u2514\u2500\u2500 UserLookupController.php \u2502 \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 Controllers/ \u2502 \u2502 \u251c\u2500\u2500 BookLookupController.php \u2502 \u2502 \u2514\u2500\u2500 UserLookupController.php \u2502 \u251c\u2500\u2500 Entities/ \u2502 \u2502 \u251c\u2500\u2500 Book.php \u2502 \u2502 \u2514\u2500\u2500 User.php \u2502 \u2514\u2500\u2500 Repositories/ \u2502 \u251c\u2500\u2500 BookRepository.php \u2502 \u2514\u2500\u2500 UserRepository.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock Connection pools \u00b6 \u26a0\ufe0f Feature preview This is a feature preview, i.e. it might not have made it into the current beta. Give feedback to help us prioritize. We also welcome contributors to help out! If you're using X behind a traditional web server , there's nothing to worry about: PHP will process a single request and then clean up afterward (shared-nothing architecture). Likewise, any database connection will be created as part of the request handling and will be closed after the request has been handled. Because the number of parallel PHP processes is limited (usually through a PHP-FPM configuration), this also ensures the number of concurrent database connections is limited. If you're using X with its built-in web server , things behave differently: a single PHP process will take care of handling any number of requests concurrently. Because this process is kept running, this means we can reuse state such as database connections. This provides a significant performance boost as we do not have to recreate the connection and exchange authentication credentials for each request. As such, using the built-in web server gives you more options on how to handle these database connections. Set up a database connection for each request and clean up afterward: Same characteristics as traditional shared-nothing architecture. Needs to juggle with multiple database connection objects and missing out on significant performance boost. Create a single database connection and reuse this across multiple requests: Significantly less connection setup and promises noticeable performance boost. However, database queries will be processed in order over a single connection and a single slow query may thus negatively impact all following queries ( Head-of-line blocking ). The best compromise between both extremes is a database connection pool: Your code interfaces with a single database connection object that will automatically create a limited number of underlying database connections as needed. There is ongoing effort to provide built-in support for database connection pools for all database adapters, possible through the async DBAL described above. Once ready, switching to the connection pool should only be a matter of minutes, not hours. Expect more details later this year.","title":"Database"},{"location":"integrations/database/#database","text":"One of the most commonly used functionality in web APIs is database access. X supports efficient and fast database access by using async database APIs.","title":"Database"},{"location":"integrations/database/#quickstart","text":"Let's take a look at the most basic async database integration possible with X: Fibers Coroutines Promises public/index.php <?php use function React\\Async\\await ; require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { $result = await ( $db -> query ( 'SELECT COUNT(*) AS count FROM book' )); $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { $result = yield $db -> query ( 'SELECT COUNT(*) AS count FROM book' ); $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book' , function () use ( $db ) { return $db -> query ( 'SELECT COUNT(*) AS count FROM book' ) -> then ( function ( React\\MySQL\\QueryResult $result ) { $data = \"Found \" . $result -> resultRows [ 0 ][ 'count' ] . \" books \\n \" ; return React\\Http\\Message\\Response :: plaintext ( $data ); }); }); $app -> run () : As you can see, using an async database adapter in X is very similar to using a normal, synchronous database adapter such as PDO.","title":"Quickstart"},{"location":"integrations/database/#why-async","text":"Because performance. Using async, non-blocking APIs allows much faster response times by doing multiple things at once, instead of having to do one thing after another. This can be seen when we process multiple concurrent operations at once (such as sending queries to multiple databases or concurrent HTTP requests) or when using the built-in web server which can process thousands of requests at the same time. Especially with Fibers, using async database APIs should be no more complicated than their slower, synchronous counterparts. So the real question should be: Why not?","title":"Why async?"},{"location":"integrations/database/#fibers-coroutines-promises","text":"The database examples showcase the three different ways to consume async APIs. There are different reasons to pick one over the other, here's a quick overview to help you decide. Fibers allow consuming async APIs using a synchronous code flow. The await() function can be used to \"await\" a promise or to \"unwrap\" its resolution value. Fibers are a core ingredient of PHP 8.1+, but the same syntax also works on older PHP versions to some degree if you only have limited concurrency. See also Fibers for more details. Coroutines allow consuming async APIs in a way that resembles a synchronous code flow. The yield keyword function can be used to \"await\" a promise or to \"unwrap\" its resolution value. Internally, this turns the entire function into a Generator which does affect the way return values need to be accessed. See also Coroutines for more details. Promises are a core building block used in all our async APIs. They are especially useful if want to express a concurrent code flow. You can directly use their API for maximum performance or use Fibers or Coroutines as an easier way to work with async APIs. See also Promises for more details. Which style is better? We like choice. Feel free to use whatever style works best for you.","title":"Fibers / Coroutines / Promises"},{"location":"integrations/database/#database-adapters","text":"Using another database? Don't worry. ReactPHP provides support for major database vendors through a number of ready-to-use packages: MySQL Postgres SQLite Redis ClickHouse And more \u2026 Installing a new database adapter is usually as simple as executing a single composer require call. Most implementations are written in pure PHP and do not require any extensions. All adapters provide similar APIs that allow async access to the given database. In this documentation, we focus on MySQL because it is one of the more common database choices for web development, but the same ideas also apply to all other database implementations. \u2139\ufe0f Legacy, blocking database access? For performance reasons, we highly recommend using async database APIs as described above. For legacy integrations, we provide limited support for blocking database calls such as PDO, Doctrine, etc., but as a rule of thumb, going for an async alternative is usually somewhat more efficient. See child processes for more details.","title":"Database adapters"},{"location":"integrations/database/#dbal","text":"\u26a0\ufe0f Feature preview This is a feature preview, i.e. it might not have made it into the current beta. Give feedback to help us prioritize. We also welcome contributors to help out! There is ongoing effort to provide an async DBAL (DataBase Abstraction Layer) that will allow you to write your logic in such a way that it is not tied to a specific database adapter. Among others, this will make it easier to support multiple database adapters in a single code base, which is particularly useful for reusable components such as middleware classes . You may also use this to configure different database adapters for testing purposes (such as using SQLite for integration tests and using MySQL in production). At the moment, we recommend using one of the above database adapters directly. Looking forward, the idea is to add an abstraction that uses a common API and provides a native integration with these adapters. Accordingly, switching to the new DBAL APIs should only be a matter of a few minutes, not hours. Expect more details later this year. On top of this, there are ideas to build an ORM (Object-Relational Mapping) in the future. More details will follow.","title":"DBAL"},{"location":"integrations/database/#best-practices","text":"","title":"Best practices"},{"location":"integrations/database/#query-parameters","text":"We highly recommend using SQL statements with placeholders for query parameters instead of manually building SQL statements by concatenating quoted strings. For most database adapters, this would be faster, provide additional guarantees against possible SQL injection attacks, and also make the SQL statement easier to understand. As a common example, we can accept a request attribute from a route placeholder like this: Fibers Coroutines Promises public/index.php <?php use function React\\Async\\await ; require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book/{isbn}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) use ( $db ) { $isbn = $request -> getAttribute ( 'isbn' ); $result = await ( $db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] )); assert ( $result instanceof React\\MySQL\\QueryResult ); if ( count ( $result -> resultRows ) === 0 ) { return React\\Http\\Message\\Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( React\\Http\\Message\\Response :: STATUS_NOT_FOUND ); } $data = $result -> resultRows [ 0 ][ 'title' ]; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book/{isbn}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) use ( $db ) { $isbn = $request -> getAttribute ( 'isbn' ); $result = yield $db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ); assert ( $result instanceof React\\MySQL\\QueryResult ); if ( count ( $result -> resultRows ) === 0 ) { return React\\Http\\Message\\Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( React\\Http\\Message\\Response :: STATUS_NOT_FOUND ); } $data = $result -> resultRows [ 0 ][ 'title' ]; return React\\Http\\Message\\Response :: plaintext ( $data ); }); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $app = new FrameworkX\\App (); $app -> get ( '/book/{isbn}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) use ( $db ) { $isbn = $request -> getAttribute ( 'isbn' ); return $db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ) -> then ( function ( React\\MySQL\\QueryResult $result ) { if ( count ( $result -> resultRows ) === 0 ) { return React\\Http\\Message\\Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( React\\Http\\Message\\Response :: STATUS_NOT_FOUND ); } $data = $result -> resultRows [ 0 ][ 'title' ]; return React\\Http\\Message\\Response :: plaintext ( $data ); }); }); $app -> run ();","title":"Query parameters"},{"location":"integrations/database/#recommended-class-structure","text":"The above examples use inline closure definitions to ease getting started, but it's also easy to see how this will get out of hand for more complex business domains when you have more than a couple of routes registered. For real-world applications, we highly recommend structuring your application into individual controller classes . This way, we can break up this logic into multiple smaller files, that are easier to work with, easier to test in isolation, and easier to reason about. As a starting point, we recommend the following class and directory structure: acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 Book.php \u2502 \u251c\u2500\u2500 BookRepository.php \u2502 \u2514\u2500\u2500 BookLookupController.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock \u2139\ufe0f We \u2764\ufe0f Domain-Driven Design We're big fans of DDD (Domain-Driven Design), which basically is a fancy way of saying: The design of your application should be driven by your business domain requirements, not by some arbitrary technical constraints. In this instance, this means we're breaking up the database logic into their logic parts and using a repository pattern to isolate the entity ( Book ) from the database logic ( BookRepository ) and from the request logic ( BookLookupController ). For newcomers, this may sound like a lot of code at first but actually helps reduce clutter down the line. But don't worry, X does not enforce a particular style, so none of this is strictly required. Use your own best judgment, see controller classes for more details. The main entry point registers a route for our controller and uses dependency injection (DI) or a DI container to wire all classes: Constructor dependency injection DI container public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $credentials = 'alice:secret@localhost/bookstore' ; $db = ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); $repository = new Acme\\Todo\\BookRepository ( $db ); $app = new FrameworkX\\App (); $app -> get ( '/book/{isbn}' , new Acme\\Todo\\BookLookupController ( $repository )); $app -> run (); public/index.php <?php require __DIR__ . '/../vendor/autoload.php' ; $container = new FrameworkX\\Container ([ React\\MySQL\\ConnectionInterface :: class => function () { $credentials = 'alice:secret@localhost/bookstore' ; return ( new React\\MySQL\\Factory ()) -> createLazyConnection ( $credentials ); } ]); $app = new FrameworkX\\App ( $container ); $app -> get ( '/book/{isbn}' , Acme\\Todo\\BookLookupController :: class ); $app -> run (); The main entity we're dealing with in this example is a plain PHP class which makes it super easy to write and to use in our code: Readonly constructor property (PHP 8.1+) Typed property (PHP 7.4+) Old school property src/Book.php <?php namespace Acme\\Todo ; class Book { public function __construct ( public readonly string $title ) { } } src/Book.php <?php namespace Acme\\Todo ; class Book { /** @readonly **/ public string $title ; public function __construct ( string $title ) { $this -> title = $title ; } } src/Book.php <?php namespace Acme\\Todo ; class Book { /** * @var string * @readonly */ public $title ; public function __construct ( string $title ) { $this -> title = $title ; } } The database logic and request handling is separated into two classes that interface with each other using a simple async API: Fibers Coroutines Promises src/BookRepository.php <?php namespace Acme\\Todo ; use React\\MySQL\\ConnectionInterface ; use React\\MySQL\\QueryResult ; use function React\\Async\\await ; class BookRepository { private $db ; public function __construct ( ConnectionInterface $db ) { $this -> db = $db ; } public function findBook ( string $isbn ) : ? Book { $result = await ( $this -> db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] )); assert ( $result instanceof QueryResult ); if ( count ( $result -> resultRows ) === 0 ) { return null ; } return new Book ( $result -> resultRows [ 0 ][ 'title' ]); } } src/BookLookupController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class BookLookupController { private $repository ; public function __construct ( BookRepository $repository ) { $this -> repository = $repository ; } public function __invoke ( ServerRequestInterface $request ) : ResponseInterface { $isbn = $request -> getAttribute ( 'isbn' ); $book = $this -> repository -> findBook ( $isbn ); if ( $book === null ) { return Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( Response :: STATUS_NOT_FOUND ); } $data = $book -> title ; return Response :: plaintext ( $data ); } } src/BookRepository.php <?php namespace Acme\\Todo ; use React\\MySQL\\ConnectionInterface ; use React\\MySQL\\QueryResult ; use React\\Promise\\PromiseInterface ; class BookRepository { private $db ; public function __construct ( ConnectionInterface $db ) { $this -> db = $db ; } /** @return \\Generator<mixed,PromiseInterface,mixed,?Book> **/ public function findBook ( string $isbn ) : \\Generator { $result = yield $this -> db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ); assert ( $result instanceof QueryResult ); if ( count ( $result -> resultRows ) === 0 ) { return null ; } return new Book ( $result -> resultRows [ 0 ][ 'title' ]); } } src/BookLookupController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; use React\\Promise\\PromiseInterface ; class BookLookupController { private $repository ; public function __construct ( BookRepository $repository ) { $this -> repository = $repository ; } /** @return \\Generator<mixed,PromiseInterface,mixed,ResponseInterface> **/ public function __invoke ( ServerRequestInterface $request ) : \\Generator { $isbn = $request -> getAttribute ( 'isbn' ); $book = yield from $this -> repository -> findBook ( $isbn ); assert ( $book === null || $book instanceof Book ); if ( $book === null ) { return Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( Response :: STATUS_NOT_FOUND ); } $data = $book -> title ; return Response :: plaintext ( $data ); } } src/BookRepository.php <?php namespace Acme\\Todo ; use React\\MySQL\\ConnectionInterface ; use React\\MySQL\\QueryResult ; use React\\Promise\\PromiseInterface ; class BookRepository { private $db ; public function __construct ( ConnectionInterface $db ) { $this -> db = $db ; } /** @return PromiseInterface<?Book> **/ public function findBook ( string $isbn ) : PromiseInterface { return $this -> db -> query ( 'SELECT title FROM book WHERE isbn = ?' , [ $isbn ] ) -> then ( function ( QueryResult $result ) { if ( count ( $result -> resultRows ) === 0 ) { return null ; } return new Book ( $result -> resultRows [ 0 ][ 'title' ]); }); } } src/BookLookupController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; use React\\Promise\\PromiseInterface ; class BookLookupController { private $repository ; public function __construct ( BookRepository $repository ) { $this -> repository = $repository ; } /** @return PromiseInterface<ResponseInterface> **/ public function __invoke ( ServerRequestInterface $request ) : PromiseInterface { $isbn = $request -> getAttribute ( 'isbn' ); return $this -> repository -> findBook ( $isbn ) -> then ( function ( ? Book $book ) { if ( $book === null ) { return Response :: plaintext ( \"Book not found \\n \" ) -> withStatus ( Response :: STATUS_NOT_FOUND ); } $data = $book -> title ; return Response :: plaintext ( $data ); }); } } That's it. We do realize that this looks like a lot of classes, but if you take a look at the code in each class, you'll find that most of this is actually pretty straightforward. Both the logic and the code structure itself are pretty obvious and easy to reason about and improve upon when more features are added. As a next step, we would highly recommend looking into testing . Because we've broken down the logic into very small units, it should be easy to write unit tests that allow us to cover 100% of our logic. See testing for more details. acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 Book.php \u2502 \u251c\u2500\u2500 BookRepository.php \u2502 \u2514\u2500\u2500 BookLookupController.php \u251c\u2500\u2500 tests/ \u2502 \u251c\u2500\u2500 BookTest.php \u2502 \u251c\u2500\u2500 BookRepositoryTest.php \u2502 \u2514\u2500\u2500 BookLookupControllerTest.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock The above structure is what we recommend as a starting point if you're unsure. Once your application starts growing, you will likely want to introduce additional layers to group logic and make cohesion between different classes more obvious. There are multiple ways to go about this, but here are two common structures to get you started: Group by domain Group by functionality acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 Book/ \u2502 \u2502 \u251c\u2500\u2500 Book.php \u2502 \u2502 \u251c\u2500\u2500 BookRepository.php \u2502 \u2502 \u2514\u2500\u2500 BookLookupController.php \u2502 \u2514\u2500\u2500 User/ \u2502 \u251c\u2500\u2500 User.php \u2502 \u251c\u2500\u2500 UserRepository.php \u2502 \u2514\u2500\u2500 UserLookupController.php \u2502 \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock acme/ \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 Controllers/ \u2502 \u2502 \u251c\u2500\u2500 BookLookupController.php \u2502 \u2502 \u2514\u2500\u2500 UserLookupController.php \u2502 \u251c\u2500\u2500 Entities/ \u2502 \u2502 \u251c\u2500\u2500 Book.php \u2502 \u2502 \u2514\u2500\u2500 User.php \u2502 \u2514\u2500\u2500 Repositories/ \u2502 \u251c\u2500\u2500 BookRepository.php \u2502 \u2514\u2500\u2500 UserRepository.php \u251c\u2500\u2500 vendor/ \u251c\u2500\u2500 composer.json \u2514\u2500\u2500 composer.lock","title":"Recommended class structure"},{"location":"integrations/database/#connection-pools","text":"\u26a0\ufe0f Feature preview This is a feature preview, i.e. it might not have made it into the current beta. Give feedback to help us prioritize. We also welcome contributors to help out! If you're using X behind a traditional web server , there's nothing to worry about: PHP will process a single request and then clean up afterward (shared-nothing architecture). Likewise, any database connection will be created as part of the request handling and will be closed after the request has been handled. Because the number of parallel PHP processes is limited (usually through a PHP-FPM configuration), this also ensures the number of concurrent database connections is limited. If you're using X with its built-in web server , things behave differently: a single PHP process will take care of handling any number of requests concurrently. Because this process is kept running, this means we can reuse state such as database connections. This provides a significant performance boost as we do not have to recreate the connection and exchange authentication credentials for each request. As such, using the built-in web server gives you more options on how to handle these database connections. Set up a database connection for each request and clean up afterward: Same characteristics as traditional shared-nothing architecture. Needs to juggle with multiple database connection objects and missing out on significant performance boost. Create a single database connection and reuse this across multiple requests: Significantly less connection setup and promises noticeable performance boost. However, database queries will be processed in order over a single connection and a single slow query may thus negatively impact all following queries ( Head-of-line blocking ). The best compromise between both extremes is a database connection pool: Your code interfaces with a single database connection object that will automatically create a limited number of underlying database connections as needed. There is ongoing effort to provide built-in support for database connection pools for all database adapters, possible through the async DBAL described above. Once ready, switching to the connection pool should only be a matter of minutes, not hours. Expect more details later this year.","title":"Connection pools"},{"location":"integrations/filesystem/","text":"Filesystem \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Async APIs with Promises Avoid using blocking fopen() , file_get_contents() and family Few blocking calls can be acceptable See reactphp/filesystem for filesystem prototype Avoid blocking filesystem by using child process See clue/reactphp-s3 for async S3 filesystem API (supporting Amazon S3, Ceph, MiniIO, DigitalOcean Spaces and others)","title":"\u26a0 Filesystem"},{"location":"integrations/filesystem/#filesystem","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Async APIs with Promises Avoid using blocking fopen() , file_get_contents() and family Few blocking calls can be acceptable See reactphp/filesystem for filesystem prototype Avoid blocking filesystem by using child process See clue/reactphp-s3 for async S3 filesystem API (supporting Amazon S3, Ceph, MiniIO, DigitalOcean Spaces and others)","title":"Filesystem"},{"location":"integrations/queueing/","text":"Queueing \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Common requirement to offload work from frontend to background workers Major queue vendors supported already BunnyPHP for AMQP (RabbitMQ) Redis with blocking lists and streams Experimental STOMP support for RabbitMQ, Apollo, ActiveMQ, etc. Future optionally built-in queueing support with no external dependencies, but swappable","title":"\u26a0 Queueing"},{"location":"integrations/queueing/#queueing","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Common requirement to offload work from frontend to background workers Major queue vendors supported already BunnyPHP for AMQP (RabbitMQ) Redis with blocking lists and streams Experimental STOMP support for RabbitMQ, Apollo, ActiveMQ, etc. Future optionally built-in queueing support with no external dependencies, but swappable","title":"Queueing"},{"location":"integrations/sessions/","text":"Sessions \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Session handling common requirement and not hard to implement Implementation as HTTP middleware recommended Handling credentials application-specific, may take advantage of database See also authentication","title":"\u26a0 Sessions"},{"location":"integrations/sessions/#sessions","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Session handling common requirement and not hard to implement Implementation as HTTP middleware recommended Handling credentials application-specific, may take advantage of database See also authentication","title":"Sessions"},{"location":"integrations/streaming/","text":"Streaming \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Processing large amounts of data or when data arrives at future time. Streaming downloads \u00b6 Efficient processing of large files without keeping contents in memory Similar for video streaming, but not scope of this project EventSource \u00b6 HTML5 Server-Sent Events (SSE) aka. EventSource supported out-of-the-box Live streaming, live data, realtime communication WebSockets \u00b6 HTML5 WebSockets integration supported with Ratchet See also EventSource as alternative Bidirectional communication","title":"\u26a0 Streaming"},{"location":"integrations/streaming/#streaming","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Processing large amounts of data or when data arrives at future time.","title":"Streaming"},{"location":"integrations/streaming/#streaming-downloads","text":"Efficient processing of large files without keeping contents in memory Similar for video streaming, but not scope of this project","title":"Streaming downloads"},{"location":"integrations/streaming/#eventsource","text":"HTML5 Server-Sent Events (SSE) aka. EventSource supported out-of-the-box Live streaming, live data, realtime communication","title":"EventSource"},{"location":"integrations/streaming/#websockets","text":"HTML5 WebSockets integration supported with Ratchet See also EventSource as alternative Bidirectional communication","title":"WebSockets"},{"location":"integrations/templates/","text":"Templates \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Very common requirement, especially for HTML pages Any template language possible Twig Handlebars Mustache Template files often loaded from filesystem (avoid blocking)","title":"\u26a0 Templates"},{"location":"integrations/templates/#templates","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Very common requirement, especially for HTML pages Any template language possible Twig Handlebars Mustache Template files often loaded from filesystem (avoid blocking)","title":"Templates"}]}